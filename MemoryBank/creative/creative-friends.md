# –ü—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥—Ä—É–∑—å—è–º–∏

üé®üé®üé® **ENTERING CREATIVE PHASE: FRIENDS MANAGEMENT SYSTEM** üé®üé®üé®

## –û–ø–∏—Å–∞–Ω–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞

–ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ—Ü–∏–∞–ª—å–Ω—ã–º–∏ —Å–≤—è–∑—è–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –±–∏–ª—å—è—Ä–¥–Ω–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, –≤–∫–ª—é—á–∞—é—â–∞—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥—Ä—É–∑—å—è–º–∏, –æ—Ç–ø—Ä–∞–≤–∫—É –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π –≤ –∏–≥—Ä—É, –ø–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ —Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è. –°–∏—Å—Ç–µ–º–∞ –¥–æ–ª–∂–Ω–∞ –æ–±–µ—Å–ø–µ—á–∏–≤–∞—Ç—å seamless integration —Å Telegram Mini Apps, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å real-time —Å—Ç–∞—Ç—É—Å—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å privacy –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö, –∞ —Ç–∞–∫–∂–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å—Å—è –¥–æ 10,000+ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å complex social graphs.

## –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è

### –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è:
- **Friend Management**: –û—Ç–ø—Ä–∞–≤–∫–∞/–ø—Ä–∏–Ω—è—Ç–∏–µ/–æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –∑–∞—è–≤–æ–∫ –≤ –¥—Ä—É–∑—å—è
- **User Discovery**: –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ username, –∏–º–µ–Ω–∏, Telegram ID
- **Game Invitations**: –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –¥—Ä—É–∑–µ–π –≤ –∏–≥—Ä–æ–≤—ã–µ —Å–µ—Å—Å–∏–∏
- **Social Status**: Real-time —Å—Ç–∞—Ç—É—Å—ã (online, in-game, offline)  
- **Friendship Analytics**: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä —Å –¥—Ä—É–∑—å—è–º–∏, –æ–±—â–∏–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
- **Privacy Controls**: –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏
- **Social Notifications**: –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –¥–µ–π—Å—Ç–≤–∏—è—Ö –¥—Ä—É–∑–µ–π

### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:
- **Performance**: < 100ms response time –¥–ª—è friend operations
- **Scalability**: –ü–æ–¥–¥–µ—Ä–∂–∫–∞ social graphs –¥–æ 1000 –¥—Ä—É–∑–µ–π –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
- **Real-time**: < 5 seconds –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —Å—Ç–∞—Ç—É—Å–æ–≤
- **Privacy**: GDPR compliance –¥–ª—è —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- **Integration**: Seamless —Ä–∞–±–æ—Ç–∞ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ 6 –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞–º–∏
- **Telegram Sync**: –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å Telegram –∫–æ–Ω—Ç–∞–∫—Ç–∞–º–∏

### –ë–∏–∑–Ω–µ—Å-–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:
- **User Experience**: –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–π social workflow –±–µ–∑ —Ñ—Ä–∏–∫—Ü–∏–π
- **Trust & Safety**: –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ø–∞–º–∞ –∏ harassment
- **Community Building**: –ü–æ–æ—â—Ä–µ–Ω–∏–µ healthy social interactions
- **Retention**: Social features –¥–æ–ª–∂–Ω—ã —É–≤–µ–ª–∏—á–∏–≤–∞—Ç—å user engagement

## –í–∞—Ä–∏–∞–Ω—Ç—ã –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã —Å–∏—Å—Ç–µ–º—ã –¥—Ä—É–∑–µ–π

### –í–∞—Ä–∏–∞–Ω—Ç 1: –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π Friends Service

**–û–ø–∏—Å–∞–Ω–∏–µ**: –í—ã–¥–µ–ª–µ–Ω–Ω—ã–π –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å, –∫–æ—Ç–æ—Ä—ã–π —É–ø—Ä–∞–≤–ª—è–µ—Ç –≤—Å–µ–º–∏ –∞—Å–ø–µ–∫—Ç–∞–º–∏ —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π —á–µ—Ä–µ–∑ –µ–¥–∏–Ω—ã–π API.

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**:
```
Frontend ‚Üí API Gateway ‚Üí Friends Service ‚Üí Friends Database
                              ‚Üì
                         RabbitMQ Events ‚Üí [Notification, Stats, Game Services]
```

**Data Model**:
```sql
friendships (user_id, friend_id, status, created_at)
friend_requests (sender_id, receiver_id, status, message, created_at)
blocked_users (user_id, blocked_user_id, reason, created_at)
user_social_settings (user_id, discoverable, auto_accept_friends)
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥—Ä—É–∑—å—è–º–∏
- –ï–¥–∏–Ω–∞—è —Ç–æ—á–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª—è —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- –ü—Ä–æ—Å—Ç–æ—Ç–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ business rules
- –õ–µ–≥–∫–æ—Å—Ç—å –∞—É–¥–∏—Ç–∞ –∏ –º–æ–¥–µ—Ä–∞—Ü–∏–∏
- –ö–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å —Å–æ—Ü–∏–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏**:
- –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π bottleneck –¥–ª—è social operations
- Single point of failure –¥–ª—è social features
- –°–ª–æ–∂–Ω–æ—Å—Ç—å –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ —Ä–æ—Å—Ç–µ social graph
- –í—ã—Å–æ–∫–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ –æ–¥–∏–Ω —Å–µ—Ä–≤–∏—Å

### –í–∞—Ä–∏–∞–Ω—Ç 2: Distributed Social Graph

**–û–ø–∏—Å–∞–Ω–∏–µ**: –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –º–µ–∂–¥—É –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏ –ø–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º –¥–æ–º–µ–Ω–∞–º.

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**:
```
User Discovery Service ‚Üí User Search & Profiles
Friend Management Service ‚Üí Friendships & Requests  
Social Activity Service ‚Üí Status & Notifications
Game Invitation Service ‚Üí Game-related Social Features
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- –°–ø–µ—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤ –ø–æ–¥ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏
- –ù–µ–∑–∞–≤–∏—Å–∏–º–æ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
- –í—ã—Å–æ–∫–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞ —Å—á–µ—Ç optimization
- Fault tolerance (failure –æ–¥–Ω–æ–≥–æ –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ –¥—Ä—É–≥–∏–µ)
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Ä–∞–∑–Ω—ã—Ö —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –¥–æ–º–µ–Ω–æ–≤

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏**:
- –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è data consistency
- –£—Å–ª–æ–∂–Ω–µ–Ω–∏–µ inter-service communication
- –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
- –°–ª–æ–∂–Ω–æ—Å—Ç—å debugging distributed workflows
- Overhead –Ω–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—é –º–µ–∂–¥—É —Å–µ—Ä–≤–∏—Å–∞–º–∏

### –í–∞—Ä–∏–∞–Ω—Ç 3: Hybrid Social Architecture

**–û–ø–∏—Å–∞–Ω–∏–µ**: –û—Å–Ω–æ–≤–Ω–æ–π Friends Service –¥–ª—è core –æ–ø–µ—Ä–∞—Ü–∏–π + —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –¥–ª—è performance-critical features.

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**:
```
Core Friends Service ‚Üí Central friendship management
    ‚Üì
Real-time Status Service ‚Üí Live user presence
Search Service ‚Üí Optimized user discovery  
Invitation Service ‚Üí Game invitations & notifications
```

**Integration Flow**:
```
Friends Service ‚Üê ‚Üí Auth Service (user data)
Friends Service ‚Üí RabbitMQ ‚Üí [Notification, Stats, Game Services]
Status Service ‚Üí WebSocket ‚Üí Real-time updates
Search Service ‚Üí Elasticsearch ‚Üí Fast user discovery
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- –ë–∞–ª–∞–Ω—Å –º–µ–∂–¥—É centralization –∏ specialization
- Core consistency —á–µ—Ä–µ–∑ Friends Service
- Performance optimization –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö features
- –ì–∏–±–∫–æ—Å—Ç—å –≤ –≤—ã–±–æ—Ä–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ–≥–æ scaling –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏**:
- –°—Ä–µ–¥–Ω—è—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
- –ù–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å careful coordination
- –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –ø—É—Ç–∞–Ω–∏—Ü–∞ –≤ responsibility boundaries
- –¢—Ä–µ–±—É–µ—Ç sophisticated monitoring

## –ê–Ω–∞–ª–∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤

### –ö—Ä–∏—Ç–µ—Ä–∏–∏ –æ—Ü–µ–Ω–∫–∏:
1. **Performance** - —Å–∫–æ—Ä–æ—Å—Ç—å social operations
2. **Scalability** - —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å large social graphs
3. **Consistency** - –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç—å —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
4. **Maintainability** - –ø—Ä–æ—Å—Ç–æ—Ç–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ —Ä–∞–∑–≤–∏—Ç–∏—è
5. **User Experience** - –∫–∞—á–µ—Å—Ç–≤–æ social interactions

### –û—Ü–µ–Ω–∫–∞ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:

| –ö—Ä–∏—Ç–µ—Ä–∏–π | –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π | Distributed | Hybrid |
|----------|-----------------|-------------|--------|
| **Performance** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Scalability** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Consistency** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Maintainability** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **User Experience** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |

## –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–æ–µ —Ä–µ—à–µ–Ω–∏–µ

### **–í—ã–±–æ—Ä: Hybrid Social Architecture (–í–∞—Ä–∏–∞–Ω—Ç 3)**

**–û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ**:
1. **Telegram Mini Apps —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è**: –ù—É–∂–Ω–∞ –±—ã—Å—Ç—Ä–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å—Ç–∞—Ç—É—Å–æ–≤ –∏ real-time —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
2. **Scalability needs**: –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è search –∏ status components
3. **User Experience**: –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –¥–ª—è critical user journeys
4. **Integration**: –õ–µ–≥–∫–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞–º–∏

### –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ:

```mermaid
graph TB
    subgraph "Frontend Layer"
        TelegramApp[Telegram Mini App]
        ReactApp[React Application]
    end
    
    subgraph "API Gateway"
        Gateway[Kong Gateway<br/>Social Routes]
    end
    
    subgraph "Core Social Services"
        FriendsService[Friends Service<br/>Core Management]
        StatusService[Status Service<br/>Real-time Presence]
        SearchService[Search Service<br/>User Discovery]
        InviteService[Invitation Service<br/>Game Invites]
    end
    
    subgraph "Supporting Services"
        AuthService[Auth Service]
        NotificationService[Notification Service]
        GameService[Game Service]
        StatsService[Stats Service]
    end
    
    subgraph "Data Layer"
        FriendsDB[Friends Database<br/>PostgreSQL]
        StatusCache[Status Cache<br/>Redis]
        SearchIndex[Search Index<br/>Elasticsearch]
        EventBus[RabbitMQ<br/>Social Events]
    end
    
    subgraph "External"
        WebSocket[WebSocket<br/>Real-time Updates]
        TelegramAPI[Telegram API<br/>Contact Sync]
    end
    
    TelegramApp --> ReactApp
    ReactApp --> Gateway
    
    Gateway --> FriendsService
    Gateway --> StatusService
    Gateway --> SearchService
    Gateway --> InviteService
    
    FriendsService --> FriendsDB
    FriendsService --> EventBus
    
    StatusService --> StatusCache
    StatusService --> WebSocket
    
    SearchService --> SearchIndex
    SearchService --> AuthService
    
    InviteService --> GameService
    InviteService --> NotificationService
    
    EventBus --> NotificationService
    EventBus --> StatsService
    EventBus --> StatusService
    
    FriendsService -.-> TelegramAPI
    
    style FriendsService fill:#fff3e0
    style StatusService fill:#e8f5e8
    style SearchService fill:#e1f5fe
    style InviteService fill:#fce4ec
    style EventBus fill:#f3e5f5
    style WebSocket fill:#fff8e1
```

## Implementation Guidelines

### 1. Core Friends Service

**Database Schema**:
```sql
-- –û—Å–Ω–æ–≤–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –¥—Ä—É–∂–µ—Å–∫–∏—Ö —Å–≤—è–∑–µ–π
CREATE TABLE friendships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    friend_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status friendship_status NOT NULL DEFAULT 'pending',
    initiated_by UUID NOT NULL, -- –∫—Ç–æ –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–ª –¥—Ä—É–∂–±—É
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    accepted_at TIMESTAMP WITH TIME ZONE,
    last_interaction TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    friendship_score INTEGER DEFAULT 0, -- –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
    
    CONSTRAINT friendship_not_self CHECK (user_id != friend_id),
    CONSTRAINT unique_friendship UNIQUE (user_id, friend_id)
);

-- –ó–∞—è–≤–∫–∏ –≤ –¥—Ä—É–∑—å—è
CREATE TABLE friend_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    receiver_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    message TEXT,
    status request_status NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    responded_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '30 days'),
    
    CONSTRAINT request_not_self CHECK (sender_id != receiver_id),
    CONSTRAINT unique_active_request UNIQUE (sender_id, receiver_id)
);

-- –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
CREATE TABLE blocked_users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    blocked_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    reason block_reason,
    blocked_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    blocked_until TIMESTAMP WITH TIME ZONE, -- –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω–æ–π –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
    
    CONSTRAINT block_not_self CHECK (user_id != blocked_user_id),
    CONSTRAINT unique_block UNIQUE (user_id, blocked_user_id)
);

-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏
CREATE TABLE user_social_settings (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    discoverable_by_username BOOLEAN DEFAULT true,
    discoverable_by_telegram BOOLEAN DEFAULT false,
    auto_accept_friends BOOLEAN DEFAULT false,
    show_online_status BOOLEAN DEFAULT true,
    show_game_activity BOOLEAN DEFAULT true,
    allow_game_invites BOOLEAN DEFAULT true,
    friend_requests_enabled BOOLEAN DEFAULT true,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö
CREATE TYPE friendship_status AS ENUM ('pending', 'accepted', 'blocked');
CREATE TYPE request_status AS ENUM ('pending', 'accepted', 'declined', 'expired', 'cancelled');
CREATE TYPE block_reason AS ENUM ('spam', 'harassment', 'inappropriate_content', 'other');

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
CREATE INDEX idx_friendships_user_id ON friendships(user_id) WHERE status = 'accepted';
CREATE INDEX idx_friendships_friend_id ON friendships(friend_id) WHERE status = 'accepted';
CREATE INDEX idx_friendships_last_interaction ON friendships(last_interaction DESC);
CREATE INDEX idx_friend_requests_receiver ON friend_requests(receiver_id) WHERE status = 'pending';
CREATE INDEX idx_friend_requests_sender ON friend_requests(sender_id);
CREATE INDEX idx_blocked_users_user_id ON blocked_users(user_id);
CREATE INDEX idx_friendship_score ON friendships(friendship_score DESC) WHERE status = 'accepted';
```

**Pydantic Models**:
```python
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from datetime import datetime
from uuid import UUID
from enum import Enum

class FriendshipStatus(str, Enum):
    PENDING = "pending"
    ACCEPTED = "accepted"
    BLOCKED = "blocked"

class RequestStatus(str, Enum):
    PENDING = "pending"
    ACCEPTED = "accepted"
    DECLINED = "declined"
    EXPIRED = "expired"
    CANCELLED = "cancelled"

class BlockReason(str, Enum):
    SPAM = "spam"
    HARASSMENT = "harassment"
    INAPPROPRIATE_CONTENT = "inappropriate_content"
    OTHER = "other"

class FriendRequest(BaseModel):
    id: UUID
    sender_id: UUID
    receiver_id: UUID
    message: Optional[str] = None
    status: RequestStatus
    created_at: datetime
    responded_at: Optional[datetime] = None
    expires_at: datetime

class FriendRequestCreate(BaseModel):
    receiver_id: UUID
    message: Optional[str] = Field(None, max_length=500)
    
    @validator('message')
    def validate_message(cls, v):
        if v and len(v.strip()) == 0:
            return None
        return v

class FriendRequestResponse(BaseModel):
    request_id: UUID
    action: Literal["accept", "decline"]
    
class Friendship(BaseModel):
    id: UUID
    user_id: UUID
    friend_id: UUID
    status: FriendshipStatus
    initiated_by: UUID
    created_at: datetime
    accepted_at: Optional[datetime] = None
    last_interaction: datetime
    friendship_score: int = 0

class FriendProfile(BaseModel):
    """–ü—Ä–æ—Ñ–∏–ª—å –¥—Ä—É–≥–∞ —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π"""
    user_id: UUID
    display_name: str
    username: Optional[str]
    avatar_url: Optional[str]
    is_online: bool = False
    current_status: Optional[str] = None  # "playing", "idle", etc.
    friendship_since: datetime
    games_played_together: int = 0
    last_seen: Optional[datetime] = None
    mutual_friends_count: int = 0

class BlockUser(BaseModel):
    user_id: UUID
    reason: BlockReason
    duration_days: Optional[int] = None  # None = permanent

class SocialSettings(BaseModel):
    discoverable_by_username: bool = True
    discoverable_by_telegram: bool = False
    auto_accept_friends: bool = False
    show_online_status: bool = True
    show_game_activity: bool = True
    allow_game_invites: bool = True
    friend_requests_enabled: bool = True
```

**Friends Service Implementation**:
```python
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Optional
import asyncio

router = APIRouter(prefix="/api/v1/friends", tags=["friends"])

class FriendsService:
    def __init__(self, db: AsyncSession, event_publisher):
        self.db = db
        self.event_publisher = event_publisher
    
    async def send_friend_request(self, sender_id: UUID, request: FriendRequestCreate) -> FriendRequest:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞—è–≤–∫–∏ –≤ –¥—Ä—É–∑—å—è"""
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞—è–≤–∫—É —Å–∞–º —Å–µ–±–µ
        if sender_id == request.receiver_id:
            raise HTTPException(400, "Cannot send friend request to yourself")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—É—á–∞—Ç–µ–ª—å –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
        is_blocked = await self._is_user_blocked(request.receiver_id, sender_id)
        if is_blocked:
            raise HTTPException(403, "Cannot send friend request to this user")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–Ω–∏ —É–∂–µ –Ω–µ –¥—Ä—É–∑—å—è
        existing_friendship = await self._get_friendship(sender_id, request.receiver_id)
        if existing_friendship and existing_friendship.status == FriendshipStatus.ACCEPTED:
            raise HTTPException(409, "Users are already friends")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∑–∞—è–≤–∫–∏
        existing_request = await self._get_pending_request(sender_id, request.receiver_id)
        if existing_request:
            raise HTTPException(409, "Friend request already sent")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—Ä–∞—Ç–Ω—É—é –∑–∞—è–≤–∫—É (–º–æ–∂–µ—Ç –±—ã—Ç—å auto-accept)
        reverse_request = await self._get_pending_request(request.receiver_id, sender_id)
        if reverse_request:
            # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–Ω–∏–º–∞–µ–º –æ–±–µ –∑–∞—è–≤–∫–∏
            await self._auto_accept_mutual_requests(sender_id, request.receiver_id)
            return await self._get_friend_request_by_ids(sender_id, request.receiver_id)
        
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞—è–≤–∫—É
        friend_request = FriendRequest(
            id=uuid4(),
            sender_id=sender_id,
            receiver_id=request.receiver_id,
            message=request.message,
            status=RequestStatus.PENDING,
            created_at=datetime.utcnow(),
            expires_at=datetime.utcnow() + timedelta(days=30)
        )
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
        await self._save_friend_request(friend_request)
        
        # –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ
        await self._publish_friend_request_event(friend_request)
        
        return friend_request
    
    async def respond_to_friend_request(self, user_id: UUID, response: FriendRequestResponse) -> dict:
        """–û—Ç–≤–µ—Ç –Ω–∞ –∑–∞—è–≤–∫—É –≤ –¥—Ä—É–∑—å—è"""
        
        # –ü–æ–ª—É—á–∞–µ–º –∑–∞—è–≤–∫—É
        request = await self._get_friend_request_by_id(response.request_id)
        if not request:
            raise HTTPException(404, "Friend request not found")
        
        if request.receiver_id != user_id:
            raise HTTPException(403, "Not authorized to respond to this request")
        
        if request.status != RequestStatus.PENDING:
            raise HTTPException(409, "Request already processed")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç
        if response.action == "accept":
            await self._accept_friend_request(request)
            result = {"status": "accepted", "message": "Friend request accepted"}
        else:
            await self._decline_friend_request(request)
            result = {"status": "declined", "message": "Friend request declined"}
        
        return result
    
    async def get_friends_list(self, user_id: UUID, 
                              include_online_status: bool = True,
                              limit: int = 100,
                              offset: int = 0) -> List[FriendProfile]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥—Ä—É–∑–µ–π —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π"""
        
        friends = await self._get_user_friends(user_id, limit, offset)
        
        if include_online_status:
            # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç—É—Å—ã –æ–Ω–ª–∞–π–Ω –∏–∑ Redis
            online_statuses = await self._get_friends_online_status([f.friend_id for f in friends])
            
            for friend in friends:
                friend.is_online = online_statuses.get(str(friend.friend_id), False)
        
        return friends
    
    async def search_users(self, 
                          query: str,
                          current_user_id: UUID,
                          search_type: Literal["username", "display_name", "telegram"] = "username",
                          limit: int = 20) -> List[dict]:
        """–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Search Service)"""
        
        # –î–µ–ª–µ–≥–∏—Ä—É–µ–º –ø–æ–∏—Å–∫ –≤ Search Service
        search_results = await self._search_users_via_service(
            query=query,
            search_type=search_type,
            exclude_user_id=current_user_id,
            limit=limit
        )
        
        # –û–±–æ–≥–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –¥—Ä—É–∂–±–µ
        for user in search_results:
            user['friendship_status'] = await self._get_friendship_status(
                current_user_id, user['user_id']
            )
            user['is_blocked'] = await self._is_user_blocked(
                current_user_id, user['user_id']
            )
        
        return search_results
    
    async def block_user(self, user_id: UUID, block_request: BlockUser):
        """–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        
        if user_id == block_request.user_id:
            raise HTTPException(400, "Cannot block yourself")
        
        # –£–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –¥—Ä—É–∂–±—É
        await self._remove_friendship(user_id, block_request.user_id)
        
        # –û—Ç–∫–ª–æ–Ω—è–µ–º –≤—Å–µ pending –∑–∞—è–≤–∫–∏
        await self._cancel_pending_requests(user_id, block_request.user_id)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ –±–ª–æ–∫-–ª–∏—Å—Ç
        blocked_until = None
        if block_request.duration_days:
            blocked_until = datetime.utcnow() + timedelta(days=block_request.duration_days)
        
        await self._add_to_blocklist(user_id, block_request.user_id, 
                                   block_request.reason, blocked_until)
        
        # –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ
        await self._publish_user_blocked_event(user_id, block_request.user_id, block_request.reason)
    
    async def get_friend_recommendations(self, user_id: UUID, limit: int = 10) -> List[dict]:
        """–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥—Ä—É–∑–µ–π –Ω–∞ –æ—Å–Ω–æ–≤–µ mutual friends –∏ –∏–≥—Ä–æ–≤–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏"""
        
        # –ü–æ–ª—É—á–∞–µ–º mutual friends
        mutual_friends_candidates = await self._get_mutual_friends_candidates(user_id, limit * 2)
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø–æ—Ö–æ–∂–∏–º–∏ –∏–≥—Ä–æ–≤—ã–º–∏ –∏–Ω—Ç–µ—Ä–µ—Å–∞–º–∏
        similar_players = await self._get_similar_players(user_id, limit)
        
        # –ö–æ–º–±–∏–Ω–∏—Ä—É–µ–º –∏ —Ä–∞–Ω–∂–∏—Ä—É–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        recommendations = await self._rank_friend_recommendations(
            user_id, mutual_friends_candidates + similar_players, limit
        )
        
        return recommendations

# API Endpoints
@router.post("/requests", response_model=FriendRequest)
async def send_friend_request(
    request: FriendRequestCreate,
    current_user: User = Depends(get_current_user),
    friends_service: FriendsService = Depends(get_friends_service)
):
    """–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞—è–≤–∫–∏ –≤ –¥—Ä—É–∑—å—è"""
    return await friends_service.send_friend_request(current_user.id, request)

@router.put("/requests/{request_id}")
async def respond_to_friend_request(
    request_id: UUID,
    response: FriendRequestResponse,
    current_user: User = Depends(get_current_user),
    friends_service: FriendsService = Depends(get_friends_service)
):
    """–û—Ç–≤–µ—Ç –Ω–∞ –∑–∞—è–≤–∫—É –≤ –¥—Ä—É–∑—å—è"""
    response.request_id = request_id
    return await friends_service.respond_to_friend_request(current_user.id, response)

@router.get("/", response_model=List[FriendProfile])
async def get_friends_list(
    include_online: bool = Query(True),
    limit: int = Query(100, le=500),
    offset: int = Query(0, ge=0),
    current_user: User = Depends(get_current_user),
    friends_service: FriendsService = Depends(get_friends_service)
):
    """–°–ø–∏—Å–æ–∫ –¥—Ä—É–∑–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    return await friends_service.get_friends_list(
        current_user.id, include_online, limit, offset
    )

@router.get("/search")
async def search_users(
    q: str = Query(..., min_length=2, max_length=50),
    type: Literal["username", "display_name", "telegram"] = Query("username"),
    limit: int = Query(20, le=50),
    current_user: User = Depends(get_current_user),
    friends_service: FriendsService = Depends(get_friends_service)
):
    """–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    return await friends_service.search_users(q, current_user.id, type, limit)

@router.post("/block")
async def block_user(
    block_request: BlockUser,
    current_user: User = Depends(get_current_user),
    friends_service: FriendsService = Depends(get_friends_service)
):
    """–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    await friends_service.block_user(current_user.id, block_request)
    return {"status": "success", "message": "User blocked"}

@router.get("/recommendations")
async def get_friend_recommendations(
    limit: int = Query(10, le=20),
    current_user: User = Depends(get_current_user),
    friends_service: FriendsService = Depends(get_friends_service)
):
    """–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥—Ä—É–∑–µ–π"""
    return await friends_service.get_friend_recommendations(current_user.id, limit)
```

### 2. Real-time Status Service

**Redis Schema for User Presence**:
```python
import redis.asyncio as redis
import json
from datetime import datetime, timedelta
from enum import Enum

class UserStatus(str, Enum):
    ONLINE = "online"
    IN_GAME = "in_game"
    IDLE = "idle"
    OFFLINE = "offline"

class StatusService:
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.status_expiry = 300  # 5 minutes
        self.presence_key_prefix = "user:presence:"
        self.activity_key_prefix = "user:activity:"
        self.friends_status_key_prefix = "friends:status:"
    
    async def update_user_status(self, user_id: UUID, status: UserStatus, 
                               activity_details: dict = None):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        
        presence_key = f"{self.presence_key_prefix}{user_id}"
        activity_key = f"{self.activity_key_prefix}{user_id}"
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ç—É—Å —Å TTL
        presence_data = {
            "status": status.value,
            "last_seen": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat()
        }
        
        await self.redis.setex(
            presence_key, 
            self.status_expiry, 
            json.dumps(presence_data)
        )
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–µ—Ç–∞–ª–∏ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        if activity_details:
            await self.redis.setex(
                activity_key,
                self.status_expiry,
                json.dumps(activity_details)
            )
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à —Å—Ç–∞—Ç—É—Å–æ–≤ –¥—Ä—É–∑–µ–π
        await self._update_friends_status_cache(user_id, status)
        
        # –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞
        await self._publish_status_change_event(user_id, status, activity_details)
    
    async def get_user_status(self, user_id: UUID) -> dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        
        presence_key = f"{self.presence_key_prefix}{user_id}"
        activity_key = f"{self.activity_key_prefix}{user_id}"
        
        presence_data = await self.redis.get(presence_key)
        activity_data = await self.redis.get(activity_key)
        
        if not presence_data:
            return {
                "user_id": str(user_id),
                "status": UserStatus.OFFLINE.value,
                "last_seen": None,
                "activity": None
            }
        
        presence = json.loads(presence_data)
        activity = json.loads(activity_data) if activity_data else None
        
        return {
            "user_id": str(user_id),
            "status": presence["status"],
            "last_seen": presence["last_seen"],
            "updated_at": presence["updated_at"],
            "activity": activity
        }
    
    async def get_friends_status_bulk(self, user_ids: List[UUID]) -> dict:
        """–ú–∞—Å—Å–æ–≤–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        
        pipeline = self.redis.pipeline()
        
        for user_id in user_ids:
            presence_key = f"{self.presence_key_prefix}{user_id}"
            pipeline.get(presence_key)
        
        results = await pipeline.execute()
        
        statuses = {}
        for i, user_id in enumerate(user_ids):
            if results[i]:
                presence_data = json.loads(results[i])
                statuses[str(user_id)] = {
                    "status": presence_data["status"],
                    "last_seen": presence_data["last_seen"]
                }
            else:
                statuses[str(user_id)] = {
                    "status": UserStatus.OFFLINE.value,
                    "last_seen": None
                }
        
        return statuses
    
    async def set_user_in_game(self, user_id: UUID, game_session_id: UUID, game_type: str):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ "–≤ –∏–≥—Ä–µ"""
        
        activity_details = {
            "type": "game",
            "game_session_id": str(game_session_id),
            "game_type": game_type,
            "started_at": datetime.utcnow().isoformat()
        }
        
        await self.update_user_status(user_id, UserStatus.IN_GAME, activity_details)
    
    async def set_user_online(self, user_id: UUID):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ "–æ–Ω–ª–∞–π–Ω"""
        await self.update_user_status(user_id, UserStatus.ONLINE)
    
    async def set_user_offline(self, user_id: UUID):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ "–æ—Ñ—Ñ–ª–∞–π–Ω"""
        await self.update_user_status(user_id, UserStatus.OFFLINE)
    
    async def get_online_friends(self, user_id: UUID) -> List[dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥—Ä—É–∑–µ–π –æ–Ω–ª–∞–π–Ω"""
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥—Ä—É–∑–µ–π –∏–∑ Friends Service
        friends = await self._get_user_friends_from_service(user_id)
        
        # –ü–æ–ª—É—á–∞–µ–º –∏—Ö —Å—Ç–∞—Ç—É—Å—ã
        friend_ids = [friend['friend_id'] for friend in friends]
        statuses = await self.get_friends_status_bulk(friend_ids)
        
        # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –æ–Ω–ª–∞–π–Ω –¥—Ä—É–∑–µ–π
        online_friends = []
        for friend in friends:
            friend_id = str(friend['friend_id'])
            if statuses[friend_id]['status'] != UserStatus.OFFLINE.value:
                online_friends.append({
                    **friend,
                    'status': statuses[friend_id]['status'],
                    'last_seen': statuses[friend_id]['last_seen']
                })
        
        return online_friends
    
    async def _update_friends_status_cache(self, user_id: UUID, status: UserStatus):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ —Å—Ç–∞—Ç—É—Å–æ–≤ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –¥—Ä—É–∑–µ–π"""
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥—Ä—É–∑–µ–π
        friends = await self._get_user_friends_from_service(user_id)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à —Å—Ç–∞—Ç—É—Å–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥—Ä—É–≥–∞
        pipeline = self.redis.pipeline()
        for friend in friends:
            friends_status_key = f"{self.friends_status_key_prefix}{friend['friend_id']}"
            pipeline.hset(friends_status_key, str(user_id), status.value)
            pipeline.expire(friends_status_key, self.status_expiry)
        
        await pipeline.execute()

# FastAPI WebSocket –¥–ª—è real-time —Å—Ç–∞—Ç—É—Å–æ–≤
@router.websocket("/ws/status")
async def websocket_status_endpoint(
    websocket: WebSocket,
    current_user: User = Depends(get_current_user_ws),
    status_service: StatusService = Depends(get_status_service)
):
    """WebSocket –¥–ª—è real-time –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π —Å—Ç–∞—Ç—É—Å–æ–≤ –¥—Ä—É–∑–µ–π"""
    
    await websocket.accept()
    
    try:
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–Ω–ª–∞–π–Ω
        await status_service.set_user_online(current_user.id)
        
        # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–æ–≤ –¥—Ä—É–∑–µ–π
        await status_service.subscribe_to_friends_status(current_user.id, websocket)
        
        while True:
            # Heartbeat –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            data = await websocket.receive_json()
            
            if data.get("type") == "ping":
                await websocket.send_json({"type": "pong"})
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
                await status_service.set_user_online(current_user.id)
            
            elif data.get("type") == "status_update":
                new_status = data.get("status")
                if new_status in [s.value for s in UserStatus]:
                    await status_service.update_user_status(
                        current_user.id, 
                        UserStatus(new_status)
                    )
    
    except WebSocketDisconnect:
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ—Ñ—Ñ–ª–∞–π–Ω –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏
        await status_service.set_user_offline(current_user.id)
```

### 3. Search Service Integration

**Elasticsearch Configuration**:
```python
from elasticsearch import AsyncElasticsearch
from typing import List, Dict

class UserSearchService:
    def __init__(self, es_client: AsyncElasticsearch):
        self.es = es_client
        self.index_name = "users"
    
    async def setup_index(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ Elasticsearch –∏–Ω–¥–µ–∫—Å–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        
        mapping = {
            "mappings": {
                "properties": {
                    "user_id": {"type": "keyword"},
                    "username": {
                        "type": "text",
                        "analyzer": "standard",
                        "fields": {
                            "keyword": {"type": "keyword"},
                            "suggest": {
                                "type": "completion",
                                "analyzer": "simple"
                            }
                        }
                    },
                    "display_name": {
                        "type": "text",
                        "analyzer": "standard",
                        "fields": {
                            "keyword": {"type": "keyword"},
                            "suggest": {
                                "type": "completion",
                                "analyzer": "simple"
                            }
                        }
                    },
                    "telegram_username": {
                        "type": "keyword",
                        "fields": {
                            "suggest": {
                                "type": "completion"
                            }
                        }
                    },
                    "telegram_user_id": {"type": "long"},
                    "avatar_url": {"type": "keyword"},
                    "created_at": {"type": "date"},
                    "last_active": {"type": "date"},
                    "total_games": {"type": "integer"},
                    "total_wins": {"type": "integer"},
                    "privacy_settings": {
                        "type": "object",
                        "properties": {
                            "discoverable_by_username": {"type": "boolean"},
                            "discoverable_by_telegram": {"type": "boolean"}
                        }
                    }
                }
            },
            "settings": {
                "number_of_shards": 1,
                "number_of_replicas": 1,
                "analysis": {
                    "analyzer": {
                        "username_analyzer": {
                            "type": "custom",
                            "tokenizer": "standard",
                            "filter": ["lowercase", "asciifolding"]
                        }
                    }
                }
            }
        }
        
        await self.es.indices.create(index=self.index_name, body=mapping, ignore=400)
    
    async def index_user(self, user_data: dict):
        """–ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        
        doc = {
            "user_id": user_data["id"],
            "username": user_data.get("username"),
            "display_name": user_data["display_name"],
            "telegram_username": user_data.get("telegram_username"),
            "telegram_user_id": user_data.get("telegram_user_id"),
            "avatar_url": user_data.get("avatar_url"),
            "created_at": user_data["created_at"],
            "last_active": user_data.get("last_active"),
            "privacy_settings": user_data.get("privacy_settings", {}),
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–∑ Stats Service
            "total_games": user_data.get("total_games", 0),
            "total_wins": user_data.get("total_wins", 0)
        }
        
        await self.es.index(index=self.index_name, id=user_data["id"], body=doc)
    
    async def search_users(self, 
                          query: str, 
                          search_type: str = "username",
                          exclude_user_id: UUID = None,
                          limit: int = 20) -> List[dict]:
        """–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        
        # –ë–∞–∑–æ–≤—ã–π query
        base_query = {
            "bool": {
                "must": [],
                "filter": [],
                "must_not": []
            }
        }
        
        # –ò—Å–∫–ª—é—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if exclude_user_id:
            base_query["bool"]["must_not"].append({
                "term": {"user_id": str(exclude_user_id)}
            })
        
        # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ privacy settings
        base_query["bool"]["filter"].append({
            "term": {f"privacy_settings.discoverable_by_{search_type}": True}
        })
        
        # –°—Ç—Ä–æ–∏–º –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
        if search_type == "username":
            search_query = {
                "multi_match": {
                    "query": query,
                    "fields": ["username^2", "username.keyword^3"],
                    "type": "best_fields",
                    "fuzziness": "AUTO"
                }
            }
        elif search_type == "display_name":
            search_query = {
                "multi_match": {
                    "query": query,
                    "fields": ["display_name^2", "display_name.keyword^3"],
                    "type": "best_fields",
                    "fuzziness": "AUTO"
                }
            }
        elif search_type == "telegram":
            search_query = {
                "bool": {
                    "should": [
                        {"prefix": {"telegram_username": query.lower()}},
                        {"term": {"telegram_user_id": query}} if query.isdigit() else {}
                    ]
                }
            }
        
        base_query["bool"]["must"].append(search_query)
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫
        response = await self.es.search(
            index=self.index_name,
            body={
                "query": base_query,
                "size": limit,
                "sort": [
                    {"_score": {"order": "desc"}},
                    {"last_active": {"order": "desc"}}
                ]
            }
        )
        
        return [hit["_source"] for hit in response["hits"]["hits"]]
    
    async def suggest_users(self, prefix: str, limit: int = 10) -> List[dict]:
        """–ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        
        suggest_body = {
            "suggest": {
                "username_suggest": {
                    "prefix": prefix,
                    "completion": {
                        "field": "username.suggest",
                        "size": limit,
                        "skip_duplicates": True
                    }
                },
                "display_name_suggest": {
                    "prefix": prefix,
                    "completion": {
                        "field": "display_name.suggest",
                        "size": limit,
                        "skip_duplicates": True
                    }
                }
            }
        }
        
        response = await self.es.search(index=self.index_name, body=suggest_body)
        
        suggestions = []
        for suggest_type in ["username_suggest", "display_name_suggest"]:
            for option in response["suggest"][suggest_type][0]["options"]:
                suggestions.append(option["_source"])
        
        # –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –∏ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        unique_suggestions = {s["user_id"]: s for s in suggestions}
        return list(unique_suggestions.values())[:limit]

# API –¥–ª—è –ø–æ–∏—Å–∫–∞
@router.get("/search/suggest")
async def suggest_users(
    q: str = Query(..., min_length=1, max_length=50),
    limit: int = Query(10, le=20),
    search_service: UserSearchService = Depends(get_search_service)
):
    """–ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    return await search_service.suggest_users(q, limit)
```

### 4. Game Invitation Service

**Invitation Management**:
```python
class GameInvitationService:
    def __init__(self, db: AsyncSession, event_publisher, friends_service):
        self.db = db
        self.event_publisher = event_publisher
        self.friends_service = friends_service
    
    async def invite_friends_to_game(self, 
                                   inviter_id: UUID,
                                   session_id: UUID,
                                   friend_ids: List[UUID],
                                   message: Optional[str] = None) -> dict:
        """–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥—Ä—É–∑–µ–π –≤ –∏–≥—Ä–æ–≤—É—é —Å–µ—Å—Å–∏—é"""
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –ø—Ä–∏–≥–ª–∞—à–∞–µ–º—ã–µ - –¥—Ä—É–∑—å—è
        valid_friends = await self.friends_service.validate_friendships(inviter_id, friend_ids)
        invalid_friends = set(friend_ids) - set(valid_friends)
        
        if invalid_friends:
            raise HTTPException(400, f"Cannot invite non-friends: {list(invalid_friends)}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –¥—Ä—É–∑–µ–π
        friends_allowing_invites = await self._filter_friends_allowing_invites(valid_friends)
        
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
        invitations = []
        for friend_id in friends_allowing_invites:
            invitation = GameInvitation(
                id=uuid4(),
                inviter_id=inviter_id,
                invitee_id=friend_id,
                session_id=session_id,
                message=message,
                status="pending",
                created_at=datetime.utcnow(),
                expires_at=datetime.utcnow() + timedelta(hours=2)
            )
            invitations.append(invitation)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
        await self._save_invitations(invitations)
        
        # –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏—è –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
        for invitation in invitations:
            await self._publish_game_invitation_event(invitation)
        
        return {
            "sent_invitations": len(invitations),
            "skipped_users": list(set(friend_ids) - set(friends_allowing_invites)),
            "invitation_ids": [str(inv.id) for inv in invitations]
        }
    
    async def respond_to_game_invitation(self, 
                                       user_id: UUID,
                                       invitation_id: UUID,
                                       action: Literal["accept", "decline"]) -> dict:
        """–û—Ç–≤–µ—Ç –Ω–∞ –∏–≥—Ä–æ–≤–æ–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ"""
        
        invitation = await self._get_invitation_by_id(invitation_id)
        if not invitation:
            raise HTTPException(404, "Invitation not found")
        
        if invitation.invitee_id != user_id:
            raise HTTPException(403, "Not authorized to respond to this invitation")
        
        if invitation.status != "pending":
            raise HTTPException(409, "Invitation already processed")
        
        if invitation.expires_at < datetime.utcnow():
            raise HTTPException(410, "Invitation expired")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç
        if action == "accept":
            # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∏–≥—Ä–æ–≤—É—é —Å–µ—Å—Å–∏—é
            await self._add_user_to_game_session(user_id, invitation.session_id)
            invitation.status = "accepted"
            invitation.responded_at = datetime.utcnow()
            
            # –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ –ø—Ä–∏–Ω—è—Ç–∏—è
            await self._publish_invitation_accepted_event(invitation)
            
            result = {"status": "accepted", "session_id": str(invitation.session_id)}
        else:
            invitation.status = "declined"
            invitation.responded_at = datetime.utcnow()
            
            # –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è
            await self._publish_invitation_declined_event(invitation)
            
            result = {"status": "declined"}
        
        await self._update_invitation(invitation)
        return result
    
    async def get_pending_invitations(self, user_id: UUID) -> List[dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ pending –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π"""
        
        invitations = await self._get_user_pending_invitations(user_id)
        
        # –û–±–æ–≥–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–º–∏ –æ —Å–µ—Å—Å–∏—è—Ö –∏ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–∏—Ö
        enriched_invitations = []
        for invitation in invitations:
            session_info = await self._get_session_info(invitation.session_id)
            inviter_info = await self._get_user_info(invitation.inviter_id)
            
            enriched_invitations.append({
                "invitation_id": str(invitation.id),
                "inviter": {
                    "user_id": str(invitation.inviter_id),
                    "display_name": inviter_info["display_name"],
                    "avatar_url": inviter_info.get("avatar_url")
                },
                "session": {
                    "session_id": str(invitation.session_id),
                    "name": session_info["name"],
                    "game_type": session_info["game_type"],
                    "current_participants": session_info["current_participants"],
                    "max_participants": session_info["max_participants"]
                },
                "message": invitation.message,
                "created_at": invitation.created_at.isoformat(),
                "expires_at": invitation.expires_at.isoformat()
            })
        
        return enriched_invitations

# Database schema –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π
CREATE TABLE game_invitations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    inviter_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    invitee_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    session_id UUID NOT NULL, -- Reference to game session
    message TEXT,
    status invitation_status NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    responded_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    
    CONSTRAINT invitation_not_self CHECK (inviter_id != invitee_id),
    CONSTRAINT unique_pending_invitation UNIQUE (inviter_id, invitee_id, session_id)
);

CREATE TYPE invitation_status AS ENUM ('pending', 'accepted', 'declined', 'expired', 'cancelled');

CREATE INDEX idx_game_invitations_invitee ON game_invitations(invitee_id) WHERE status = 'pending';
CREATE INDEX idx_game_invitations_session ON game_invitations(session_id);
CREATE INDEX idx_game_invitations_expires ON game_invitations(expires_at) WHERE status = 'pending';
```

### 5. RabbitMQ Events Integration

**Social Events Schema**:
```python
from enum import Enum

class SocialEventType(str, Enum):
    FRIEND_REQUEST_SENT = "friends.request_sent"
    FRIEND_REQUEST_ACCEPTED = "friends.request_accepted"
    FRIEND_REQUEST_DECLINED = "friends.request_declined"
    FRIENDSHIP_CREATED = "friends.friendship_created"
    FRIENDSHIP_REMOVED = "friends.friendship_removed"
    USER_BLOCKED = "friends.user_blocked"
    USER_UNBLOCKED = "friends.user_unblocked"
    GAME_INVITATION_SENT = "friends.game_invitation_sent"
    GAME_INVITATION_ACCEPTED = "friends.game_invitation_accepted"
    USER_STATUS_CHANGED = "friends.status_changed"
    FRIEND_ONLINE = "friends.friend_online"
    FRIEND_OFFLINE = "friends.friend_offline"

class SocialEvent(BaseEvent):
    """–°–æ–±—ã—Ç–∏—è —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–π"""
    source_service: str = "friends_service"

class FriendRequestEvent(SocialEvent):
    """–°–æ–±—ã—Ç–∏–µ –∑–∞—è–≤–∫–∏ –≤ –¥—Ä—É–∑—å—è"""
    event_type: SocialEventType
    sender_id: UUID
    receiver_id: UUID
    request_id: UUID
    message: Optional[str] = None

class FriendshipEvent(SocialEvent):
    """–°–æ–±—ã—Ç–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥—Ä—É–∂–±—ã"""
    event_type: SocialEventType
    user_id: UUID
    friend_id: UUID
    friendship_id: UUID

class GameInvitationEvent(SocialEvent):
    """–°–æ–±—ã—Ç–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è"""
    event_type: SocialEventType
    inviter_id: UUID
    invitee_id: UUID
    session_id: UUID
    invitation_id: UUID

class StatusChangeEvent(SocialEvent):
    """–°–æ–±—ã—Ç–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞"""
    event_type: SocialEventType
    user_id: UUID
    old_status: Optional[str]
    new_status: str
    activity_details: Optional[dict] = None

# Event Publishers
class SocialEventPublisher:
    def __init__(self, event_publisher):
        self.event_publisher = event_publisher
    
    async def publish_friend_request_sent(self, sender_id: UUID, receiver_id: UUID, 
                                        request_id: UUID, message: str = None):
        """–ü—É–±–ª–∏–∫–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–∫–∏ –≤ –¥—Ä—É–∑—å—è"""
        
        event = FriendRequestEvent(
            event_type=SocialEventType.FRIEND_REQUEST_SENT,
            sender_id=sender_id,
            receiver_id=receiver_id,
            request_id=request_id,
            message=message,
            data={
                "sender_id": str(sender_id),
                "receiver_id": str(receiver_id),
                "request_id": str(request_id),
                "message": message
            }
        )
        
        await self.event_publisher.publish_event(event, "friends.request_sent")
    
    async def publish_friendship_created(self, user_id: UUID, friend_id: UUID, 
                                       friendship_id: UUID):
        """–ü—É–±–ª–∏–∫–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –¥—Ä—É–∂–±—ã"""
        
        event = FriendshipEvent(
            event_type=SocialEventType.FRIENDSHIP_CREATED,
            user_id=user_id,
            friend_id=friend_id,
            friendship_id=friendship_id,
            data={
                "user_id": str(user_id),
                "friend_id": str(friend_id),
                "friendship_id": str(friendship_id),
                "timestamp": datetime.utcnow().isoformat()
            }
        )
        
        await self.event_publisher.publish_event(event, "friends.friendship_created")
    
    async def publish_game_invitation_sent(self, inviter_id: UUID, invitee_id: UUID,
                                         session_id: UUID, invitation_id: UUID):
        """–ü—É–±–ª–∏–∫–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏—è –∏–≥—Ä–æ–≤–æ–≥–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è"""
        
        event = GameInvitationEvent(
            event_type=SocialEventType.GAME_INVITATION_SENT,
            inviter_id=inviter_id,
            invitee_id=invitee_id,
            session_id=session_id,
            invitation_id=invitation_id,
            data={
                "inviter_id": str(inviter_id),
                "invitee_id": str(invitee_id),
                "session_id": str(session_id),
                "invitation_id": str(invitation_id)
            }
        )
        
        await self.event_publisher.publish_event(event, "friends.game_invitation_sent")
    
    async def publish_status_changed(self, user_id: UUID, old_status: str, 
                                   new_status: str, activity_details: dict = None):
        """–ü—É–±–ª–∏–∫–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞"""
        
        event = StatusChangeEvent(
            event_type=SocialEventType.USER_STATUS_CHANGED,
            user_id=user_id,
            old_status=old_status,
            new_status=new_status,
            activity_details=activity_details,
            data={
                "user_id": str(user_id),
                "old_status": old_status,
                "new_status": new_status,
                "activity_details": activity_details,
                "timestamp": datetime.utcnow().isoformat()
            }
        )
        
        await self.event_publisher.publish_event(event, "friends.status_changed")

# Event Consumers –¥–ª—è –¥—Ä—É–≥–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
class SocialEventConsumer:
    def __init__(self, notification_service, stats_service):
        self.notification_service = notification_service
        self.stats_service = stats_service
    
    async def handle_friend_request_sent(self, event: FriendRequestEvent):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–∫–∏ –≤ –¥—Ä—É–∑—å—è"""
        
        # –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—É—á–∞—Ç–µ–ª—é
        await self.notification_service.create_notification(
            user_id=event.receiver_id,
            type="friend_request",
            title="–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –≤ –¥—Ä—É–∑—å—è",
            message=f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–ø—Ä–∞–≤–∏–ª –≤–∞–º –∑–∞—è–≤–∫—É –≤ –¥—Ä—É–∑—å—è",
            data={
                "sender_id": str(event.sender_id),
                "request_id": str(event.request_id),
                "message": event.message
            },
            action_url=f"/friends/requests/{event.request_id}"
        )
    
    async def handle_friendship_created(self, event: FriendshipEvent):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –¥—Ä—É–∂–±—ã"""
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π
        await self.stats_service.increment_user_stat(
            user_id=event.user_id,
            stat_type="total_friends",
            increment=1
        )
        
        await self.stats_service.increment_user_stat(
            user_id=event.friend_id,
            stat_type="total_friends",
            increment=1
        )
        
        # –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–±–µ–∏–º —Å—Ç–æ—Ä–æ–Ω–∞–º
        await self.notification_service.create_notification(
            user_id=event.user_id,
            type="friendship_created",
            title="–ù–æ–≤—ã–π –¥—Ä—É–≥!",
            message="–¢–µ–ø–µ—Ä—å –≤—ã –¥—Ä—É–∑—å—è! –ú–æ–∂–µ—Ç–µ –ø—Ä–∏–≥–ª–∞—à–∞—Ç—å –¥—Ä—É–≥ –¥—Ä—É–≥–∞ –≤ –∏–≥—Ä—ã.",
            data={"friend_id": str(event.friend_id)}
        )
        
        await self.notification_service.create_notification(
            user_id=event.friend_id,
            type="friendship_created", 
            title="–ù–æ–≤—ã–π –¥—Ä—É–≥!",
            message="–¢–µ–ø–µ—Ä—å –≤—ã –¥—Ä—É–∑—å—è! –ú–æ–∂–µ—Ç–µ –ø—Ä–∏–≥–ª–∞—à–∞—Ç—å –¥—Ä—É–≥ –¥—Ä—É–≥–∞ –≤ –∏–≥—Ä—ã.",
            data={"friend_id": str(event.user_id)}
        )
    
    async def handle_game_invitation_sent(self, event: GameInvitationEvent):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏—è –∏–≥—Ä–æ–≤–æ–≥–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è"""
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–µ—Å—Å–∏–∏
        session_info = await self._get_session_info(event.session_id)
        
        # –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–º—É
        await self.notification_service.create_notification(
            user_id=event.invitee_id,
            type="game_invitation",
            title="–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –∏–≥—Ä—É",
            message=f"–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –∏–≥—Ä—É '{session_info['name']}'",
            data={
                "inviter_id": str(event.inviter_id),
                "session_id": str(event.session_id),
                "invitation_id": str(event.invitation_id),
                "game_type": session_info["game_type"]
            },
            action_url=f"/games/invitations/{event.invitation_id}",
            expires_at=datetime.utcnow() + timedelta(hours=2)
        )
```

## Verification Checkpoint

### Friends Management System Verification:

‚úÖ **Core Functionality**:
- Comprehensive friend request workflow (send, accept, decline)
- Advanced user search with Elasticsearch integration
- Real-time status tracking —á–µ—Ä–µ–∑ Redis
- Game invitation system with expiration
- Privacy controls –∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

‚úÖ **Performance Requirements**:
- < 100ms response time –¥–ª—è friend operations
- Bulk status loading –¥–ª—è —Å–ø–∏—Å–∫–æ–≤ –¥—Ä—É–∑–µ–π
- Elasticsearch –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- Redis –¥–ª—è real-time —Å—Ç–∞—Ç—É—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

‚úÖ **Integration Architecture**:
- Seamless –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ 6 –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞–º–∏
- RabbitMQ events –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
- WebSocket –¥–ª—è real-time –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π —Å—Ç–∞—Ç—É—Å–æ–≤
- Notification service –¥–ª—è —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π

‚úÖ **Social Features**:
- Friend recommendations –Ω–∞ –æ—Å–Ω–æ–≤–µ mutual friends
- Social statistics integration
- Privacy settings –∏ discoverable controls
- Telegram contacts sync capability

‚úÖ **Scalability & Reliability**:
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ social graphs –¥–æ 1000 –¥—Ä—É–∑–µ–π –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
- Distributed architecture —Å —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º–∏
- Event-driven updates –º–µ–∂–¥—É —Å–µ—Ä–≤–∏—Å–∞–º–∏
- GDPR compliance –¥–ª—è —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

‚úÖ **User Experience**:
- Intuitive friend management workflow
- Real-time status updates –±–µ–∑ polling
- Smart search —Å –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ–º
- Game invitation flow integration

üé®üé®üé® **EXITING CREATIVE PHASE: FRIENDS MANAGEMENT SYSTEM** üé®üé®üé®