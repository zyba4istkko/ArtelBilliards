# –ü—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ JWT –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

üé®üé®üé® **ENTERING CREATIVE PHASE: JWT AUTHENTICATION & SECURITY** üé®üé®üé®

## –û–ø–∏—Å–∞–Ω–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞

–°–∏—Å—Ç–µ–º–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –¥–ª—è Telegram Mini Apps –Ω–∞ –±–∞–∑–µ JWT —Ç–æ–∫–µ–Ω–æ–≤ —Å –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏. –î–æ–ª–∂–Ω–∞ –æ–±–µ—Å–ø–µ—á–∏—Ç—å seamless –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é —Å Telegram API, –∑–∞—â–∏—Ç—É –æ—Ç –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∞—Ç–∞–∫, —Ä–æ–ª–µ–≤—É—é –º–æ–¥–µ–ª—å –¥–æ—Å—Ç—É–ø–∞ –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å –¥–ª—è 1000+ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.

## –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è

### –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è:
- **Telegram Integration**: –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —á–µ—Ä–µ–∑ Telegram Mini Apps API
- **JWT Management**: Access/Refresh token —Å–∏—Å—Ç–µ–º–∞ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
- **Role-Based Access**: –†–æ–ª–∏ (user, session_creator, admin) —Å granular permissions
- **Session Management**: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã–º–∏ —Å–µ—Å—Å–∏—è–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- **Multi-Device Support**: –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Ö–æ–¥–∞ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
- **Token Revocation**: –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏–Ω–≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏ –∫–æ–º–ø—Ä–æ–º–µ—Ç–∞—Ü–∏–∏

### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:
- **Performance**: < 50ms –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–æ–∫–µ–Ω–∞
- **Scalability**: –ü–æ–¥–¥–µ—Ä–∂–∫–∞ 1000+ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π  
- **Security Standards**: OWASP Top 10 compliance
- **Telegram API**: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Telegram Bot API –∏ Mini Apps
- **Microservices**: –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –º–µ–∂–¥—É 6 —Å–µ—Ä–≤–∏—Å–∞–º–∏
- **Cache Performance**: Redis –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤

### –ë–∏–∑–Ω–µ—Å-–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:
- **User Experience**: –ü—Ä–æ–∑—Ä–∞—á–Ω–∞—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –±–µ–∑ –ª–∏—à–Ω–∏—Ö —à–∞–≥–æ–≤
- **Privacy**: –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- **Compliance**: GDPR compliance –¥–ª—è EU –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- **Trust**: Telegram identity –∫–∞–∫ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –ø—Ä–∞–≤–¥—ã

## –í–∞—Ä–∏–∞–Ω—Ç—ã –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏

### –í–∞—Ä–∏–∞–Ω—Ç 1: –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è (Auth Service Only)

**–û–ø–∏—Å–∞–Ω–∏–µ**: –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ—Ö–æ–¥—è—Ç —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ Auth Service.

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**:
```
Telegram Mini App ‚Üí Auth Service (JWT Generation & Validation)
                         ‚Üì
Frontend ‚Üê API Gateway ‚Üê [All Microservices validate via Auth Service]
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å—é
- –ï–¥–∏–Ω–∞—è —Ç–æ—á–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª—è –¥–æ—Å—Ç—É–ø–∞
- –ü—Ä–æ—Å—Ç–æ—Ç–∞ –∞—É–¥–∏—Ç–∞ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
- –õ–µ–≥–∫–æ—Å—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è security policies
- –ö–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏–∏

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏**:
- –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –æ—Ç–∫–∞–∑–∞ (SPOF)
- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –Ω–∞ –∫–∞–∂–¥—ã–π –∑–∞–ø—Ä–æ—Å
- –í—ã—Å–æ–∫–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ Auth Service
- –°–ª–æ–∂–Ω–æ—Å—Ç—å –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ —Ä–æ—Å—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

### –í–∞—Ä–∏–∞–Ω—Ç 2: –î–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è (JWT Self-Validation)

**–û–ø–∏—Å–∞–Ω–∏–µ**: –ö–∞–∂–¥—ã–π –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç JWT —Ç–æ–∫–µ–Ω—ã —Å –ø–æ–º–æ—â—å—é –æ–±—â–µ–≥–æ —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞.

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**:
```
Telegram Mini App ‚Üí Auth Service (JWT Generation Only)
                         ‚Üì
Frontend ‚Üí API Gateway ‚Üí [Each Service validates JWT independently]
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- –í—ã—Å–æ–∫–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (–Ω–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤)
- –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ SPOF –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
- –ü—Ä–æ—Å—Ç–æ—Ç–∞ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
- –ù–∏–∑–∫–∞—è latency –¥–ª—è API requests
- Offline –≤–∞–ª–∏–¥–∞—Ü–∏—è –≤–æ–∑–º–æ–∂–Ω–∞

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏**:
- –°–ª–æ–∂–Ω–æ—Å—Ç—å revocation —Ç–æ–∫–µ–Ω–æ–≤
- –ù–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö –∫–ª—é—á–µ–π
- –£—Å–ª–æ–∂–Ω–µ–Ω–∏–µ security updates
- –†–∏—Å–∫ –¥–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –º–µ–∂–¥—É —Å–µ—Ä–≤–∏—Å–∞–º–∏
- –°–ª–æ–∂–Ω–æ—Å—Ç—å –∞—É–¥–∏—Ç–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –≤–∞–ª–∏–¥–∞—Ü–∏–∏

### –í–∞—Ä–∏–∞–Ω—Ç 3: –ì–∏–±—Ä–∏–¥–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ (Cached Validation)

**–û–ø–∏—Å–∞–Ω–∏–µ**: –ú–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å—ã –≤–∞–ª–∏–¥–∏—Ä—É—é—Ç —Ç–æ–∫–µ–Ω—ã –ª–æ–∫–∞–ª—å–Ω–æ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º —á–µ—Ä–µ–∑ Redis –∏ fallback –Ω–∞ Auth Service.

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**:
```
Telegram Mini App ‚Üí Auth Service (JWT Generation)
                         ‚Üì
Frontend ‚Üí API Gateway ‚Üí Redis Cache ‚Üê [Microservices]
                              ‚Üì           ‚Üë
                         Auth Service ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         (Fallback validation)
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- –ë–∞–ª–∞–Ω—Å –º–µ–∂–¥—É –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å—é
- –ë—ã—Å—Ç—Ä–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —á–µ—Ä–µ–∑ –∫—ç—à (< 5ms)
- Centralized security control —á–µ—Ä–µ–∑ Auth Service
- –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è revocation —á–µ—Ä–µ–∑ cache invalidation
- Graceful degradation –ø—Ä–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –∫—ç—à–∞

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏**:
- –°–ª–æ–∂–Ω–æ—Å—Ç—å –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏
- –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç Redis availability
- –ù–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å cache consistency management
- –°–ª–æ–∂–Ω–æ—Å—Ç—å debugging —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –≤–∞–ª–∏–¥–∞—Ü–∏–∏

## –ê–Ω–∞–ª–∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤

### –ö—Ä–∏—Ç–µ—Ä–∏–∏ –æ—Ü–µ–Ω–∫–∏:
1. **Performance** - —Å–∫–æ—Ä–æ—Å—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–æ–∫–µ–Ω–æ–≤
2. **Security** - —É—Ä–æ–≤–µ–Ω—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ –∫–æ–Ω—Ç—Ä–æ–ª—è
3. **Scalability** - —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ä–∞—Å—Ç—É—â—É—é –Ω–∞–≥—Ä—É–∑–∫—É
4. **Reliability** - —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å –∫ –æ—Ç–∫–∞–∑–∞–º
5. **Maintainability** - –ø—Ä–æ—Å—Ç–æ—Ç–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π

### –û—Ü–µ–Ω–∫–∞ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:

| –ö—Ä–∏—Ç–µ—Ä–∏–π | –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è | –î–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è | –ì–∏–±—Ä–∏–¥–Ω–∞—è |
|----------|-----------------|-------------------|-----------|
| **Performance** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Security** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Scalability** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Reliability** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Maintainability** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |

## –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–æ–µ —Ä–µ—à–µ–Ω–∏–µ

### **–í—ã–±–æ—Ä: –ì–∏–±—Ä–∏–¥–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ (–í–∞—Ä–∏–∞–Ω—Ç 3)**

**–û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ**:
1. **Telegram Mini Apps —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è**: –ù—É–∂–Ω–∞ –±—ã—Å—Ç—Ä–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª—è real-time –∏–≥—Ä
2. **Security –∫—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å**: –ë–∏–ª—å—è—Ä–¥ —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –¥–µ–Ω—å–≥–∞–º–∏ —Ç—Ä–µ–±—É–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
3. **Scalability**: Redis –∫—ç—à –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—è
4. **Reliability**: Fallback –º–µ—Ö–∞–Ω–∏–∑–º –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –≤—ã—Å–æ–∫—É—é –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å

### –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ:

```mermaid
graph TB
    TelegramApp[Telegram Mini App]
    
    subgraph "Frontend"
        ReactApp[React Application]
        TokenManager[Token Manager]
    end
    
    subgraph "Security Layer"
        APIGateway[API Gateway<br/>Kong/Traefik]
        AuthService[Auth Service<br/>JWT Generation]
        RedisCache[Redis Cache<br/>Token Validation]
    end
    
    subgraph "Microservices"
        GameSvc[Game Service]
        StatsSvc[Stats Service]
        FriendsSvc[Friends Service]
        TemplateSvc[Template Service]
        NotifySvc[Notification Service]
    end
    
    subgraph "Storage"
        AuthDB[Auth Database<br/>User Sessions]
        RedisStore[Redis Store<br/>Active Tokens]
    end
    
    TelegramApp --> ReactApp
    ReactApp --> TokenManager
    TokenManager --> APIGateway
    
    APIGateway --> AuthService
    APIGateway --> RedisCache
    
    AuthService --> AuthDB
    AuthService --> RedisStore
    RedisCache --> RedisStore
    
    APIGateway --> GameSvc
    APIGateway --> StatsSvc
    APIGateway --> FriendsSvc
    APIGateway --> TemplateSvc
    APIGateway --> NotifySvc
    
    GameSvc -.-> RedisCache
    StatsSvc -.-> RedisCache
    FriendsSvc -.-> RedisCache
    TemplateSvc -.-> RedisCache
    NotifySvc -.-> RedisCache
    
    style TelegramApp fill:#e1f5fe
    style AuthService fill:#fff3e0
    style RedisCache fill:#e8f5e8
    style APIGateway fill:#fce4ec
    style AuthDB fill:#f3e5f5
    style RedisStore fill:#fff8e1
```

## Implementation Guidelines

### 1. Telegram Mini Apps Integration

**Telegram Auth Flow**:
```python
from telegram import WebApp
import hmac
import hashlib
from urllib.parse import unquote

class TelegramAuthValidator:
    def __init__(self, bot_token: str):
        self.bot_secret = hashlib.sha256(bot_token.encode()).digest()
    
    def validate_telegram_data(self, init_data: str) -> dict:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –æ—Ç Telegram Mini App"""
        try:
            # –ü–∞—Ä—Å–∏–º init_data
            parsed_data = self._parse_init_data(init_data)
            received_hash = parsed_data.pop('hash', None)
            
            if not received_hash:
                raise ValueError("Missing hash in init_data")
            
            # –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä–æ–∫—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
            data_check_string = '\n'.join([
                f"{k}={v}" for k, v in sorted(parsed_data.items())
            ])
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å—å
            secret_key = hmac.new(
                self.bot_secret, 
                data_check_string.encode(), 
                hashlib.sha256
            ).hexdigest()
            
            if not hmac.compare_digest(received_hash, secret_key):
                raise ValueError("Invalid Telegram signature")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è (–¥–∞–Ω–Ω—ã–µ –Ω–µ —Å—Ç–∞—Ä—à–µ 1 —á–∞—Å–∞)
            auth_date = int(parsed_data.get('auth_date', 0))
            if time.time() - auth_date > 3600:
                raise ValueError("Auth data too old")
            
            return parsed_data
            
        except Exception as e:
            logger.error(f"Telegram auth validation failed: {e}")
            raise HTTPException(401, "Invalid Telegram authentication")
    
    def _parse_init_data(self, init_data: str) -> dict:
        """–ü–∞—Ä—Å–∏–Ω–≥ init_data –æ—Ç Telegram"""
        data = {}
        for item in init_data.split('&'):
            if '=' in item:
                key, value = item.split('=', 1)
                data[key] = unquote(value)
        return data
```

**Auth API Endpoint**:
```python
@router.post("/auth/telegram", response_model=AuthResponse)
async def telegram_auth(
    request: TelegramAuthRequest,
    db: AsyncSession = Depends(get_db),
    auth_validator: TelegramAuthValidator = Depends(get_telegram_validator)
):
    """–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —á–µ—Ä–µ–∑ Telegram Mini App"""
    
    # –í–∞–ª–∏–¥–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç Telegram
    telegram_data = auth_validator.validate_telegram_data(request.init_data)
    
    # –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user = await get_or_create_user_by_telegram_id(
        db, telegram_data['id'], telegram_data
    )
    
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º JWT —Ç–æ–∫–µ–Ω—ã
    access_token = create_access_token(user)
    refresh_token = create_refresh_token(user)
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–µ—Å—Å–∏—é
    session = await create_user_session(
        db, user.id, refresh_token, request.device_info
    )
    
    # –ö—ç—à–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω –≤ Redis
    await cache_token(access_token, user.id, expires_in=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    return AuthResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer",
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        user=UserProfile.from_orm(user)
    )
```

### 2. JWT Token Structure

**Access Token Payload**:
```python
{
    # Standard Claims
    "sub": "user_uuid_here",           # Subject (User ID)
    "iss": "artel_billiards",          # Issuer
    "aud": "telegram_mini_app",        # Audience
    "exp": 1642684800,                 # Expiration (15 minutes)
    "iat": 1642681200,                 # Issued At
    "nbf": 1642681200,                 # Not Before
    "jti": "token_uuid_here",          # JWT ID –¥–ª—è revocation
    
    # Custom Claims
    "telegram_id": 123456789,          # Telegram User ID
    "username": "john_doe",            # Telegram Username
    "display_name": "John Doe",        # Display Name
    "roles": ["user", "session_creator"], # User Roles
    "permissions": [                   # Granular Permissions
        "games:read",
        "games:write", 
        "sessions:create",
        "stats:read"
    ],
    "session_id": "session_uuid",      # Current Session ID
    "device_id": "device_uuid",        # Device Identifier
    "is_verified": true,               # Telegram Verification Status
    "security_level": "standard"       # Security Level
}
```

**Refresh Token Payload**:
```python
{
    "sub": "user_uuid_here",
    "iss": "artel_billiards", 
    "aud": "refresh_service",
    "exp": 1644499200,                 # Expiration (30 days)
    "iat": 1642681200,
    "jti": "refresh_token_uuid",
    "type": "refresh",
    "session_id": "session_uuid",
    "device_id": "device_uuid"
}
```

### 3. Token Generation & Validation

**JWT Service Implementation**:
```python
import jwt
from datetime import datetime, timedelta
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

class JWTService:
    def __init__(self):
        self.algorithm = "RS256"
        self.access_token_expire_minutes = 15
        self.refresh_token_expire_days = 30
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª—é—á–∏ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ (–≤ production –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ secure storage)
        self.private_key, self.public_key = self._generate_keys()
    
    def create_access_token(self, user: User, additional_claims: dict = None) -> str:
        """–°–æ–∑–¥–∞–Ω–∏–µ access token"""
        now = datetime.utcnow()
        expire = now + timedelta(minutes=self.access_token_expire_minutes)
        
        payload = {
            "sub": str(user.id),
            "iss": "artel_billiards",
            "aud": "telegram_mini_app",
            "exp": expire,
            "iat": now,
            "nbf": now,
            "jti": str(uuid4()),
            
            # Custom claims
            "telegram_id": user.telegram_user_id,
            "username": user.username,
            "display_name": user.display_name,
            "roles": [role.name for role in user.roles],
            "permissions": self._get_user_permissions(user),
            "is_verified": user.is_verified,
            "security_level": "standard"
        }
        
        if additional_claims:
            payload.update(additional_claims)
        
        return jwt.encode(payload, self.private_key, algorithm=self.algorithm)
    
    def create_refresh_token(self, user: User, session_id: str, device_id: str) -> str:
        """–°–æ–∑–¥–∞–Ω–∏–µ refresh token"""
        now = datetime.utcnow()
        expire = now + timedelta(days=self.refresh_token_expire_days)
        
        payload = {
            "sub": str(user.id),
            "iss": "artel_billiards",
            "aud": "refresh_service", 
            "exp": expire,
            "iat": now,
            "jti": str(uuid4()),
            "type": "refresh",
            "session_id": session_id,
            "device_id": device_id
        }
        
        return jwt.encode(payload, self.private_key, algorithm=self.algorithm)
    
    def validate_token(self, token: str, audience: str = "telegram_mini_app") -> dict:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è JWT —Ç–æ–∫–µ–Ω–∞"""
        try:
            payload = jwt.decode(
                token,
                self.public_key,
                algorithms=[self.algorithm],
                audience=audience,
                issuer="artel_billiards"
            )
            return payload
            
        except jwt.ExpiredSignatureError:
            raise HTTPException(401, detail="Token expired")
        except jwt.InvalidAudienceError:
            raise HTTPException(401, detail="Invalid token audience")
        except jwt.InvalidIssuerError:
            raise HTTPException(401, detail="Invalid token issuer")
        except jwt.InvalidTokenError:
            raise HTTPException(401, detail="Invalid token")
    
    def _generate_keys(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è RSA –∫–ª—é—á–µ–π –¥–ª—è JWT"""
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048
        )
        public_key = private_key.public_key()
        
        return private_key, public_key
    
    def _get_user_permissions(self, user: User) -> List[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ permissions –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        permissions = []
        for role in user.roles:
            permissions.extend(role.permissions)
        return list(set(permissions))  # Remove duplicates
```

### 4. Redis Caching Strategy

**Token Caching Implementation**:
```python
import redis.asyncio as redis
import json
from typing import Optional

class TokenCache:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
        self.prefix = "auth:token:"
        self.user_prefix = "auth:user:"
    
    async def cache_token(self, token: str, user_id: str, expires_in: int):
        """–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞"""
        token_key = f"{self.prefix}{self._get_token_hash(token)}"
        user_key = f"{self.user_prefix}{user_id}"
        
        # –ü–∞—Ä—Å–∏–º —Ç–æ–∫–µ–Ω –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è claims
        payload = jwt.decode(token, verify=False)  # –ë–µ–∑ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è –∫—ç—à–∞
        
        token_data = {
            "user_id": user_id,
            "telegram_id": payload.get("telegram_id"),
            "roles": payload.get("roles", []),
            "permissions": payload.get("permissions", []),
            "session_id": payload.get("session_id"),
            "device_id": payload.get("device_id"),
            "is_verified": payload.get("is_verified", False),
            "expires_at": payload.get("exp")
        }
        
        # –ö—ç—à–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω
        await self.redis.setex(
            token_key, 
            expires_in, 
            json.dumps(token_data)
        )
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–∫–µ–Ω –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –¥–ª—è batch invalidation
        await self.redis.sadd(user_key, token_key)
        await self.redis.expire(user_key, expires_in)
    
    async def get_token_data(self, token: str) -> Optional[dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–∞ –∏–∑ –∫—ç—à–∞"""
        token_key = f"{self.prefix}{self._get_token_hash(token)}"
        
        cached_data = await self.redis.get(token_key)
        if cached_data:
            return json.loads(cached_data)
        return None
    
    async def invalidate_token(self, token: str):
        """–ò–Ω–≤–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞"""
        token_key = f"{self.prefix}{self._get_token_hash(token)}"
        await self.redis.delete(token_key)
    
    async def invalidate_user_tokens(self, user_id: str):
        """–ò–Ω–≤–∞–ª–∏–¥–∞—Ü–∏—è –≤—Å–µ—Ö —Ç–æ–∫–µ–Ω–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        user_key = f"{self.user_prefix}{user_id}"
        
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–æ–∫–µ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        token_keys = await self.redis.smembers(user_key)
        
        if token_keys:
            # –£–¥–∞–ª—è–µ–º –≤—Å–µ —Ç–æ–∫–µ–Ω—ã
            await self.redis.delete(*token_keys)
            # –û—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            await self.redis.delete(user_key)
    
    async def is_token_revoked(self, token: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–µ –æ—Ç–æ–∑–≤–∞–Ω –ª–∏ —Ç–æ–∫–µ–Ω"""
        token_key = f"{self.prefix}{self._get_token_hash(token)}:revoked"
        return await self.redis.exists(token_key)
    
    async def revoke_token(self, token: str, expires_in: int):
        """–û—Ç–∑—ã–≤ —Ç–æ–∫–µ–Ω–∞ (–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ blacklist)"""
        token_key = f"{self.prefix}{self._get_token_hash(token)}:revoked"
        await self.redis.setex(token_key, expires_in, "1")
    
    def _get_token_hash(self, token: str) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ö—ç—à–∞ —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∫–ª—é—á–∞"""
        import hashlib
        return hashlib.sha256(token.encode()).hexdigest()[:16]
```

### 5. Authentication Middleware

**FastAPI Middleware Implementation**:
```python
from fastapi import Request, HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import time

security = HTTPBearer(auto_error=False)

class AuthMiddleware:
    def __init__(self, jwt_service: JWTService, token_cache: TokenCache):
        self.jwt_service = jwt_service
        self.token_cache = token_cache
    
    async def __call__(self, 
                      request: Request,
                      credentials: HTTPAuthorizationCredentials = Depends(security)
                      ) -> Optional[dict]:
        """Middleware –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–æ–∫–µ–Ω–æ–≤"""
        
        if not credentials:
            return None  # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
        
        token = credentials.credentials
        
        try:
            # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à Redis (–±—ã—Å—Ç—Ä–æ)
            cached_data = await self.token_cache.get_token_data(token)
            if cached_data:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º expiration
                if cached_data["expires_at"] < time.time():
                    await self.token_cache.invalidate_token(token)
                    raise HTTPException(401, "Token expired")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º revocation
                if await self.token_cache.is_token_revoked(token):
                    raise HTTPException(401, "Token revoked")
                
                return cached_data
            
            # 2. Fallback –Ω–∞ JWT validation
            payload = self.jwt_service.validate_token(token)
            
            # 3. –ö—ç—à–∏—Ä—É–µ–º –≤–∞–ª–∏–¥–Ω—ã–π —Ç–æ–∫–µ–Ω
            expires_in = payload["exp"] - int(time.time())
            if expires_in > 0:
                await self.token_cache.cache_token(
                    token, payload["sub"], expires_in
                )
            
            return payload
            
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Auth middleware error: {e}")
            raise HTTPException(401, "Authentication failed")

# Dependency –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async def get_current_user(
    auth_data: dict = Depends(AuthMiddleware),
    db: AsyncSession = Depends(get_db)
) -> User:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    if not auth_data:
        raise HTTPException(401, "Authentication required")
    
    user_id = auth_data["user_id"]
    user = await get_user_by_id(db, user_id)
    
    if not user:
        raise HTTPException(401, "User not found")
    
    return user

# Dependency –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–æ–ª–µ–π
def require_roles(*required_roles: str):
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–æ–ª–µ–π"""
    def role_checker(auth_data: dict = Depends(AuthMiddleware)):
        if not auth_data:
            raise HTTPException(401, "Authentication required")
        
        user_roles = set(auth_data.get("roles", []))
        required_roles_set = set(required_roles)
        
        if not user_roles.intersection(required_roles_set):
            raise HTTPException(403, f"Required roles: {required_roles}")
        
        return auth_data
    
    return role_checker

# Dependency –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ permissions
def require_permissions(*required_permissions: str):
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ permissions"""
    def permission_checker(auth_data: dict = Depends(AuthMiddleware)):
        if not auth_data:
            raise HTTPException(401, "Authentication required")
        
        user_permissions = set(auth_data.get("permissions", []))
        required_permissions_set = set(required_permissions)
        
        if not user_permissions.intersection(required_permissions_set):
            raise HTTPException(403, f"Required permissions: {required_permissions}")
        
        return auth_data
    
    return permission_checker
```

### 6. Role-Based Access Control (RBAC)

**Database Models for RBAC**:
```sql
-- –†–æ–ª–∏ –≤ —Å–∏—Å—Ç–µ–º–µ
CREATE TABLE user_roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    is_system_role BOOLEAN DEFAULT false,  -- –°–∏—Å—Ç–µ–º–Ω—ã–µ —Ä–æ–ª–∏ –Ω–µ–ª—å–∑—è —É–¥–∞–ª—è—Ç—å
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Permissions –≤ —Å–∏—Å—Ç–µ–º–µ
CREATE TABLE permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,  -- e.g. "games:read", "sessions:create"
    description TEXT,
    resource VARCHAR(50) NOT NULL,      -- e.g. "games", "sessions", "stats"
    action VARCHAR(50) NOT NULL,        -- e.g. "read", "write", "create", "delete"
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- –°–≤—è–∑—å —Ä–æ–ª–µ–π –∏ permissions
CREATE TABLE role_permissions (
    role_id UUID NOT NULL REFERENCES user_roles(id) ON DELETE CASCADE,
    permission_id UUID NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, permission_id)
);

-- –°–≤—è–∑—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ —Ä–æ–ª–µ–π
CREATE TABLE user_role_assignments (
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role_id UUID NOT NULL REFERENCES user_roles(id) ON DELETE CASCADE,
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    assigned_by UUID REFERENCES users(id),
    expires_at TIMESTAMP WITH TIME ZONE,  -- –î–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ä–æ–ª–µ–π
    PRIMARY KEY (user_id, role_id)
);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
CREATE INDEX idx_user_role_assignments_user_id ON user_role_assignments(user_id);
CREATE INDEX idx_user_role_assignments_role_id ON user_role_assignments(role_id);
CREATE INDEX idx_role_permissions_role_id ON role_permissions(role_id);
CREATE INDEX idx_permissions_resource_action ON permissions(resource, action);
```

**System Roles Definition**:
```sql
-- –°–∏—Å—Ç–µ–º–Ω—ã–µ —Ä–æ–ª–∏
INSERT INTO user_roles (name, description, is_system_role) VALUES
('user', '–û–±—ã—á–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å', true),
('session_creator', '–°–æ–∑–¥–∞—Ç–µ–ª—å –∏–≥—Ä–æ–≤—ã—Ö —Å–µ—Å—Å–∏–π', true),
('moderator', '–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä —Å–æ–æ–±—â–µ—Å—Ç–≤–∞', true),
('admin', '–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Å–∏—Å—Ç–µ–º—ã', true);

-- –ë–∞–∑–æ–≤—ã–µ permissions
INSERT INTO permissions (name, description, resource, action) VALUES
-- Games permissions
('games:read', '–ü—Ä–æ—Å–º–æ—Ç—Ä –∏–≥—Ä', 'games', 'read'),
('games:write', '–£—á–∞—Å—Ç–∏–µ –≤ –∏–≥—Ä–∞—Ö', 'games', 'write'),
('games:create', '–°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä', 'games', 'create'),
('games:delete', '–£–¥–∞–ª–µ–Ω–∏–µ –∏–≥—Ä', 'games', 'delete'),
('games:moderate', '–ú–æ–¥–µ—Ä–∞—Ü–∏—è –∏–≥—Ä', 'games', 'moderate'),

-- Sessions permissions
('sessions:read', '–ü—Ä–æ—Å–º–æ—Ç—Ä —Å–µ—Å—Å–∏–π', 'sessions', 'read'),
('sessions:create', '–°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–π', 'sessions', 'create'),
('sessions:join', '–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ —Å–µ—Å—Å–∏—è–º', 'sessions', 'join'),
('sessions:manage', '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Å—Å–∏—è–º–∏', 'sessions', 'manage'),
('sessions:delete', '–£–¥–∞–ª–µ–Ω–∏–µ —Å–µ—Å—Å–∏–π', 'sessions', 'delete'),

-- Stats permissions
('stats:read', '–ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏', 'stats', 'read'),
('stats:read_all', '–ü—Ä–æ—Å–º–æ—Ç—Ä –≤—Å–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏', 'stats', 'read_all'),

-- Friends permissions
('friends:read', '–ü—Ä–æ—Å–º–æ—Ç—Ä –¥—Ä—É–∑–µ–π', 'friends', 'read'),
('friends:manage', '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥—Ä—É–∑—å—è–º–∏', 'friends', 'manage'),

-- Templates permissions
('templates:read', '–ü—Ä–æ—Å–º–æ—Ç—Ä —à–∞–±–ª–æ–Ω–æ–≤', 'templates', 'read'),
('templates:create', '–°–æ–∑–¥–∞–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤', 'templates', 'create'),
('templates:edit', '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤', 'templates', 'edit'),
('templates:delete', '–£–¥–∞–ª–µ–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤', 'templates', 'delete'),

-- Admin permissions
('admin:users', '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏', 'admin', 'users'),
('admin:system', '–°–∏—Å—Ç–µ–º–Ω–æ–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ', 'admin', 'system');

-- –°–≤—è–∑—ã–≤–∞–µ–º —Ä–æ–ª–∏ —Å permissions
-- User role
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id FROM user_roles r, permissions p 
WHERE r.name = 'user' AND p.name IN (
    'games:read', 'games:write', 'sessions:read', 'sessions:join',
    'stats:read', 'friends:read', 'friends:manage', 'templates:read'
);

-- Session Creator role (–Ω–∞—Å–ª–µ–¥—É–µ—Ç User + –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∞)
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id FROM user_roles r, permissions p 
WHERE r.name = 'session_creator' AND p.name IN (
    'games:read', 'games:write', 'games:create', 'sessions:read', 
    'sessions:create', 'sessions:join', 'sessions:manage',
    'stats:read', 'friends:read', 'friends:manage', 
    'templates:read', 'templates:create', 'templates:edit'
);

-- Moderator role
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id FROM user_roles r, permissions p 
WHERE r.name = 'moderator' AND p.name IN (
    'games:read', 'games:write', 'games:create', 'games:moderate',
    'sessions:read', 'sessions:create', 'sessions:join', 'sessions:manage',
    'stats:read', 'stats:read_all', 'friends:read', 'friends:manage',
    'templates:read', 'templates:create', 'templates:edit'
);

-- Admin role (–≤—Å–µ –ø—Ä–∞–≤–∞)
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id FROM user_roles r, permissions p 
WHERE r.name = 'admin';
```

### 7. Security Headers & CORS

**Security Configuration**:
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
import secure

def configure_security(app: FastAPI):
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    
    # CORS –¥–ª—è Telegram Mini Apps
    app.add_middleware(
        CORSMiddleware,
        allow_origins=[
            "https://telegram.org",
            "https://web.telegram.org", 
            "https://k.telegram.org",
            "https://z.telegram.org",
            "https://venus.web.telegram.org",
            "https://pluto.web.telegram.org",
            "https://aurora.web.telegram.org"
        ],
        allow_credentials=True,
        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allow_headers=[
            "Authorization",
            "Content-Type",
            "X-Requested-With",
            "X-Request-ID",
            "Telegram-Bot-Api-Secret-Token"
        ],
    )
    
    # Trusted hosts
    app.add_middleware(
        TrustedHostMiddleware,
        allowed_hosts=["*.yourdomain.com", "localhost", "127.0.0.1"]
    )
    
    # Security headers
    security_headers = secure.Secure(
        csp=secure.ContentSecurityPolicy().default_src("'self'"),
        hsts=secure.StrictTransportSecurity().max_age(31536000).include_subdomains(),
        referrer=secure.ReferrerPolicy().strict_origin_when_cross_origin(),
        cache=secure.CacheControl().no_cache().no_store().must_revalidate(),
        content=secure.ContentTypeOptions().nosniff()
    )
    
    @app.middleware("http")
    async def add_security_headers(request, call_next):
        response = await call_next(request)
        security_headers.framework.fastapi(response)
        return response
```

### 8. Rate Limiting & DDoS Protection

**Rate Limiting Implementation**:
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è limiter
limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# Rate limits –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
class RateLimits:
    AUTH_LOGIN = "5/minute"        # 5 –ø–æ–ø—ã—Ç–æ–∫ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –≤ –º–∏–Ω—É—Ç—É
    AUTH_REFRESH = "10/minute"     # 10 –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π —Ç–æ–∫–µ–Ω–∞ –≤ –º–∏–Ω—É—Ç—É
    GAME_EVENTS = "60/minute"      # 60 –∏–≥—Ä–æ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π –≤ –º–∏–Ω—É—Ç—É
    API_GENERAL = "100/minute"     # 100 –æ–±—ã—á–Ω—ã—Ö API –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –º–∏–Ω—É—Ç—É
    WEBSOCKET_CONN = "10/minute"   # 10 WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π –≤ –º–∏–Ω—É—Ç—É

# –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ rate limits
@router.post("/auth/telegram")
@limiter.limit(RateLimits.AUTH_LOGIN)
async def telegram_auth(request: Request, ...):
    ...

@router.post("/auth/refresh")
@limiter.limit(RateLimits.AUTH_REFRESH)
async def refresh_token(request: Request, ...):
    ...

@router.post("/games/{game_id}/events")
@limiter.limit(RateLimits.GAME_EVENTS)
async def create_game_event(request: Request, ...):
    ...

# User-based rate limiting
def get_user_id_for_rate_limit(request: Request):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ user_id –¥–ª—è rate limiting"""
    try:
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header[7:]
            payload = jwt.decode(token, verify=False)
            return payload.get("sub", get_remote_address(request))
    except:
        pass
    return get_remote_address(request)

user_limiter = Limiter(key_func=get_user_id_for_rate_limit)

@router.post("/sessions")
@user_limiter.limit("20/hour")  # 20 —Å–µ—Å—Å–∏–π –≤ —á–∞—Å –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async def create_session(request: Request, ...):
    ...
```

### 9. Session Management

**User Session Tracking**:
```python
class SessionManager:
    def __init__(self, db: AsyncSession, cache: TokenCache):
        self.db = db
        self.cache = cache
    
    async def create_session(self, 
                           user_id: str, 
                           refresh_token: str,
                           device_info: dict) -> UserSession:
        """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π —Å–µ—Å—Å–∏–∏"""
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π (max 5 —É—Å—Ç—Ä–æ–π—Å—Ç–≤)
        active_sessions = await self.get_active_sessions(user_id)
        if len(active_sessions) >= 5:
            # –£–¥–∞–ª—è–µ–º —Å–∞–º—É—é —Å—Ç–∞—Ä—É—é —Å–µ—Å—Å–∏—é
            oldest_session = min(active_sessions, key=lambda s: s.created_at)
            await self.terminate_session(oldest_session.id)
        
        session = UserSession(
            id=str(uuid4()),
            user_id=user_id,
            refresh_token_hash=hashlib.sha256(refresh_token.encode()).hexdigest(),
            device_info=device_info,
            created_at=datetime.utcnow(),
            last_activity=datetime.utcnow(),
            is_active=True
        )
        
        self.db.add(session)
        await self.db.commit()
        return session
    
    async def update_session_activity(self, session_id: str):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Å–µ—Å—Å–∏–∏"""
        await self.db.execute(
            update(UserSession)
            .where(UserSession.id == session_id)
            .values(last_activity=datetime.utcnow())
        )
        await self.db.commit()
    
    async def terminate_session(self, session_id: str):
        """–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–µ—Å—Å–∏–∏"""
        session = await self.db.get(UserSession, session_id)
        if session:
            session.is_active = False
            session.terminated_at = datetime.utcnow()
            
            # –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –≤—Å–µ —Ç–æ–∫–µ–Ω—ã —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏
            await self.cache.invalidate_user_tokens(session.user_id)
            
            await self.db.commit()
    
    async def get_active_sessions(self, user_id: str) -> List[UserSession]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        result = await self.db.execute(
            select(UserSession)
            .where(UserSession.user_id == user_id)
            .where(UserSession.is_active == True)
            .order_by(UserSession.created_at.desc())
        )
        return result.scalars().all()
    
    async def cleanup_expired_sessions(self):
        """–û—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–µ–∫—à–∏—Ö —Å–µ—Å—Å–∏–π (–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é)"""
        expiry_threshold = datetime.utcnow() - timedelta(days=30)
        
        await self.db.execute(
            update(UserSession)
            .where(UserSession.last_activity < expiry_threshold)
            .values(is_active=False, terminated_at=datetime.utcnow())
        )
        await self.db.commit()
```

### 10. Security Monitoring & Logging

**Security Event Logging**:
```python
import logging
from enum import Enum
from datetime import datetime
from pydantic import BaseModel

class SecurityEventType(Enum):
    AUTH_SUCCESS = "auth_success"
    AUTH_FAILURE = "auth_failure"
    TOKEN_REFRESH = "token_refresh" 
    TOKEN_REVOKED = "token_revoked"
    SUSPICIOUS_ACTIVITY = "suspicious_activity"
    RATE_LIMIT_EXCEEDED = "rate_limit_exceeded"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    SESSION_HIJACK_ATTEMPT = "session_hijack_attempt"
    INVALID_SIGNATURE = "invalid_signature"

class SecurityEvent(BaseModel):
    event_type: SecurityEventType
    user_id: Optional[str]
    session_id: Optional[str] 
    ip_address: str
    user_agent: str
    timestamp: datetime
    details: dict
    risk_level: str  # "low", "medium", "high", "critical"
    
class SecurityLogger:
    def __init__(self):
        self.logger = logging.getLogger("security")
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –ª–æ–≥–≥–µ—Ä–∞ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        handler = logging.FileHandler("security.log")
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)
    
    async def log_security_event(self, event: SecurityEvent):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏"""
        
        log_data = {
            "event_type": event.event_type.value,
            "user_id": event.user_id,
            "session_id": event.session_id,
            "ip_address": event.ip_address,
            "user_agent": event.user_agent,
            "timestamp": event.timestamp.isoformat(),
            "details": event.details,
            "risk_level": event.risk_level
        }
        
        # –õ–æ–≥–∏—Ä—É–µ–º –≤ —Ñ–∞–π–ª
        if event.risk_level in ["high", "critical"]:
            self.logger.error(f"SECURITY_ALERT: {json.dumps(log_data)}")
        else:
            self.logger.info(f"SECURITY_EVENT: {json.dumps(log_data)}")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (Prometheus/Grafana)
        await self._send_to_monitoring(event)
        
        # –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å–æ–±—ã—Ç–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Slack/Telegram
        if event.risk_level == "critical":
            await self._send_alert(event)
    
    async def _send_to_monitoring(self, event: SecurityEvent):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –º–µ—Ç—Ä–∏–∫ –≤ Prometheus"""
        # Increment counter –¥–ª—è —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è
        SECURITY_EVENTS_COUNTER.labels(
            event_type=event.event_type.value,
            risk_level=event.risk_level
        ).inc()
    
    async def _send_alert(self, event: SecurityEvent):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –∞–ª–µ—Ä—Ç–æ–≤"""
        alert_message = f"""
üö® CRITICAL SECURITY ALERT üö®
Event: {event.event_type.value}
User: {event.user_id}
IP: {event.ip_address}
Time: {event.timestamp}
Details: {json.dumps(event.details, indent=2)}
        """
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Telegram/Slack –∞–¥–º–∏–Ω–∞–º
        await send_admin_notification(alert_message)

# Middleware –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
@app.middleware("http")
async def security_logging_middleware(request: Request, call_next):
    start_time = time.time()
    
    try:
        response = await call_next(request)
        
        # –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω—ã–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        if request.url.path.startswith("/api/v1/auth/") and response.status_code == 200:
            await security_logger.log_security_event(SecurityEvent(
                event_type=SecurityEventType.AUTH_SUCCESS,
                user_id=getattr(request.state, 'user_id', None),
                session_id=getattr(request.state, 'session_id', None),
                ip_address=get_client_ip(request),
                user_agent=request.headers.get("user-agent", ""),
                timestamp=datetime.utcnow(),
                details={"endpoint": str(request.url.path)},
                risk_level="low"
            ))
        
        return response
        
    except Exception as e:
        # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        if request.url.path.startswith("/api/v1/auth/"):
            await security_logger.log_security_event(SecurityEvent(
                event_type=SecurityEventType.AUTH_FAILURE,
                user_id=None,
                session_id=None,
                ip_address=get_client_ip(request),
                user_agent=request.headers.get("user-agent", ""),
                timestamp=datetime.utcnow(),
                details={"endpoint": str(request.url.path), "error": str(e)},
                risk_level="medium"
            ))
        raise
```

### 11. Suspicious Activity Detection

**Anomaly Detection System**:
```python
from collections import defaultdict
from datetime import timedelta
import asyncio

class SuspiciousActivityDetector:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.rules = [
            self._detect_multiple_failed_logins,
            self._detect_unusual_access_patterns,
            self._detect_token_abuse,
            self._detect_rapid_session_creation,
            self._detect_geo_anomalies
        ]
    
    async def analyze_request(self, request: Request, user_id: str = None):
        """–ê–Ω–∞–ª–∏–∑ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—É—é –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"""
        
        ip_address = get_client_ip(request)
        user_agent = request.headers.get("user-agent", "")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Å–µ –ø—Ä–∞–≤–∏–ª–∞ –¥–µ—Ç–µ–∫—Ü–∏–∏
        for rule in self.rules:
            try:
                result = await rule(request, user_id, ip_address, user_agent)
                if result.is_suspicious:
                    await self._handle_suspicious_activity(result)
            except Exception as e:
                logger.error(f"Error in suspicious activity rule: {e}")
    
    async def _detect_multiple_failed_logins(self, request, user_id, ip, user_agent):
        """–î–µ—Ç–µ–∫—Ü–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –≤—Ö–æ–¥–∞"""
        
        if not request.url.path.endswith("/auth/telegram"):
            return SuspiciousActivityResult(False)
        
        # –°—á–∏—Ç–∞–µ–º –Ω–µ—É–¥–∞—á–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏ —Å —ç—Ç–æ–≥–æ IP –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π —á–∞—Å
        key = f"failed_auth:{ip}"
        failed_count = await self.redis.get(key) or 0
        failed_count = int(failed_count)
        
        if failed_count >= 5:  # 5 –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
            return SuspiciousActivityResult(
                is_suspicious=True,
                risk_level="high",
                event_type=SecurityEventType.SUSPICIOUS_ACTIVITY,
                details={
                    "rule": "multiple_failed_logins",
                    "failed_count": failed_count,
                    "ip_address": ip
                },
                recommended_action="block_ip_temporary"
            )
        
        return SuspiciousActivityResult(False)
    
    async def _detect_token_abuse(self, request, user_id, ip, user_agent):
        """–î–µ—Ç–µ–∫—Ü–∏—è –∑–ª–æ—É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞–º–∏"""
        
        if not user_id:
            return SuspiciousActivityResult(False)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤ —Å —Ä–∞–∑–Ω—ã—Ö IP –∑–∞ –∫–æ—Ä–æ—Ç–∫–æ–µ –≤—Ä–µ–º—è
        key = f"user_ips:{user_id}"
        ips_used = await self.redis.smembers(key)
        
        if len(ips_used) > 3:  # –ë–æ–ª–µ–µ 3 IP –∞–¥—Ä–µ—Å–æ–≤ –∑–∞ —á–∞—Å
            return SuspiciousActivityResult(
                is_suspicious=True,
                risk_level="medium",
                event_type=SecurityEventType.SUSPICIOUS_ACTIVITY,
                details={
                    "rule": "token_abuse",
                    "ip_count": len(ips_used),
                    "ips": list(ips_used),
                    "user_id": user_id
                },
                recommended_action="require_reauth"
            )
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–π IP –∫ —Å–ø–∏—Å–∫—É
        await self.redis.sadd(key, ip)
        await self.redis.expire(key, 3600)  # 1 —á–∞—Å
        
        return SuspiciousActivityResult(False)
    
    async def _handle_suspicious_activity(self, result: SuspiciousActivityResult):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏"""
        
        # –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–±—ã—Ç–∏–µ
        await security_logger.log_security_event(SecurityEvent(
            event_type=result.event_type,
            user_id=result.user_id,
            session_id=result.session_id,
            ip_address=result.ip_address,
            user_agent=result.user_agent,
            timestamp=datetime.utcnow(),
            details=result.details,
            risk_level=result.risk_level
        ))
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ –¥–µ–π—Å—Ç–≤–∏—è
        if result.recommended_action == "block_ip_temporary":
            await self._block_ip_temporarily(result.ip_address, duration=3600)
        elif result.recommended_action == "require_reauth":
            await self._force_user_reauth(result.user_id)
        elif result.recommended_action == "escalate_to_admin":
            await self._escalate_to_admin(result)

class SuspiciousActivityResult:
    def __init__(self, is_suspicious: bool, risk_level: str = "low", 
                 event_type: SecurityEventType = SecurityEventType.SUSPICIOUS_ACTIVITY,
                 details: dict = None, recommended_action: str = "log_only",
                 user_id: str = None, session_id: str = None, 
                 ip_address: str = None, user_agent: str = None):
        self.is_suspicious = is_suspicious
        self.risk_level = risk_level
        self.event_type = event_type
        self.details = details or {}
        self.recommended_action = recommended_action
        self.user_id = user_id
        self.session_id = session_id
        self.ip_address = ip_address
        self.user_agent = user_agent
```

### 12. Security Testing Strategy

**Automated Security Tests**:
```python
import pytest
from fastapi.testclient import TestClient
import jwt
import time

class TestSecurity:
    
    @pytest.mark.asyncio
    async def test_jwt_token_validation(self):
        """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ JWT —Ç–æ–∫–µ–Ω–æ–≤"""
        
        # –¢–µ—Å—Ç –≤–∞–ª–∏–¥–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞
        valid_token = create_test_token(user_id="test-user", exp=time.time() + 3600)
        response = client.get("/api/v1/me", headers={"Authorization": f"Bearer {valid_token}"})
        assert response.status_code == 200
        
        # –¢–µ—Å—Ç –∏—Å—Ç–µ–∫—à–µ–≥–æ —Ç–æ–∫–µ–Ω–∞
        expired_token = create_test_token(user_id="test-user", exp=time.time() - 3600)
        response = client.get("/api/v1/me", headers={"Authorization": f"Bearer {expired_token}"})
        assert response.status_code == 401
        assert "Token expired" in response.json()["detail"]
        
        # –¢–µ—Å—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞
        invalid_token = "invalid.jwt.token"
        response = client.get("/api/v1/me", headers={"Authorization": f"Bearer {invalid_token}"})
        assert response.status_code == 401
    
    @pytest.mark.asyncio 
    async def test_rate_limiting(self):
        """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ rate limiting"""
        
        # –ü—Ä–µ–≤—ã—à–∞–µ–º –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤
        for i in range(6):  # –õ–∏–º–∏—Ç 5/–º–∏–Ω—É—Ç—É
            response = client.post("/api/v1/auth/telegram", json=test_auth_data)
            if i < 5:
                assert response.status_code in [200, 401]  # –ú–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
            else:
                assert response.status_code == 429  # Too Many Requests
    
    @pytest.mark.asyncio
    async def test_role_based_access(self):
        """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–æ–ª–µ–≤–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞"""
        
        # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ä–æ–ª—å—é 'user' –ø—ã—Ç–∞–µ—Ç—Å—è —Å–æ–∑–¥–∞—Ç—å —Å–µ—Å—Å–∏—é
        user_token = create_test_token(user_id="user-1", roles=["user"])
        response = client.post("/api/v1/sessions", 
                             headers={"Authorization": f"Bearer {user_token}"},
                             json=test_session_data)
        assert response.status_code == 403  # Forbidden
        
        # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ä–æ–ª—å—é 'session_creator' —Å–æ–∑–¥–∞–µ—Ç —Å–µ—Å—Å–∏—é
        creator_token = create_test_token(user_id="user-1", roles=["session_creator"])
        response = client.post("/api/v1/sessions",
                             headers={"Authorization": f"Bearer {creator_token}"},
                             json=test_session_data)
        assert response.status_code == 201  # Created
    
    @pytest.mark.asyncio
    async def test_telegram_signature_validation(self):
        """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–æ–¥–ø–∏—Å–∏ Telegram"""
        
        # –ö–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –ø–æ–¥–ø–∏—Å—å
        valid_init_data = create_test_telegram_init_data()
        response = client.post("/api/v1/auth/telegram", json={"init_data": valid_init_data})
        assert response.status_code == 200
        
        # –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –ø–æ–¥–ø–∏—Å—å
        invalid_init_data = valid_init_data.replace("hash=", "hash=invalid")
        response = client.post("/api/v1/auth/telegram", json={"init_data": invalid_init_data})
        assert response.status_code == 401
        assert "Invalid Telegram signature" in response.json()["detail"]
    
    @pytest.mark.asyncio
    async def test_session_management(self):
        """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Å—Å–∏—è–º–∏"""
        
        # –°–æ–∑–¥–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ—Å—Å–∏–π
        tokens = []
        for i in range(6):  # –õ–∏–º–∏—Ç 5 —Å–µ—Å—Å–∏–π
            response = client.post("/api/v1/auth/telegram", json=test_auth_data)
            if response.status_code == 200:
                tokens.append(response.json()["access_token"])
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å—Ç–∞—Ä—ã–µ —Å–µ—Å—Å–∏–∏ –∏–Ω–≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–Ω—ã
        assert len(tokens) <= 5
        
        # –ü–µ—Ä–≤—ã–π —Ç–æ–∫–µ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∏–Ω–≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–Ω
        if len(tokens) == 5:
            response = client.get("/api/v1/me", headers={"Authorization": f"Bearer {tokens[0]}"})
            assert response.status_code == 401

def create_test_token(user_id: str, roles: list = None, exp: int = None) -> str:
    """–°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ JWT —Ç–æ–∫–µ–Ω–∞"""
    payload = {
        "sub": user_id,
        "iss": "artel_billiards",
        "aud": "telegram_mini_app",
        "exp": exp or int(time.time() + 3600),
        "iat": int(time.time()),
        "roles": roles or ["user"],
        "permissions": ["games:read", "sessions:read"]
    }
    return jwt.encode(payload, "test-secret", algorithm="HS256")
```

### 13. Incident Response Plan

**Security Incident Response**:
```python
from enum import Enum
from dataclasses import dataclass
from typing import List

class IncidentSeverity(Enum):
    LOW = "low"
    MEDIUM = "medium" 
    HIGH = "high"
    CRITICAL = "critical"

class IncidentType(Enum):
    DATA_BREACH = "data_breach"
    UNAUTHORIZED_ACCESS = "unauthorized_access"
    TOKEN_COMPROMISE = "token_compromise"
    DDOS_ATTACK = "ddos_attack"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    SUSPICIOUS_ACTIVITY = "suspicious_activity"

@dataclass
class SecurityIncident:
    incident_id: str
    incident_type: IncidentType
    severity: IncidentSeverity
    description: str
    affected_users: List[str]
    affected_systems: List[str]
    detected_at: datetime
    reported_by: str
    status: str = "open"  # open, investigating, resolved, closed

class IncidentResponseManager:
    def __init__(self):
        self.response_procedures = {
            IncidentType.TOKEN_COMPROMISE: self._handle_token_compromise,
            IncidentType.UNAUTHORIZED_ACCESS: self._handle_unauthorized_access,
            IncidentType.DATA_BREACH: self._handle_data_breach,
            IncidentType.DDOS_ATTACK: self._handle_ddos_attack,
        }
    
    async def handle_incident(self, incident: SecurityIncident):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏"""
        
        # 1. –ù–µ–º–µ–¥–ª–µ–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –ø–æ –∑–∞—â–∏—Ç–µ
        await self._immediate_containment(incident)
        
        # 2. –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        await self._notify_security_team(incident)
        
        # 3. –°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –ø–æ —Ç–∏–ø—É –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞
        handler = self.response_procedures.get(incident.incident_type)
        if handler:
            await handler(incident)
        
        # 4. –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞
        await self._document_incident(incident)
    
    async def _handle_token_compromise(self, incident: SecurityIncident):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–ø—Ä–æ–º–µ—Ç–∞—Ü–∏–∏ —Ç–æ–∫–µ–Ω–æ–≤"""
        
        # –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –≤—Å–µ —Ç–æ–∫–µ–Ω—ã –∑–∞—Ç—Ä–æ–Ω—É—Ç—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        for user_id in incident.affected_users:
            await token_cache.invalidate_user_tokens(user_id)
            await session_manager.terminate_all_user_sessions(user_id)
        
        # –ó–∞—Å—Ç–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—Ä–æ–π—Ç–∏ –ø–æ–≤—Ç–æ—Ä–Ω—É—é –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
        await self._force_reauth_users(incident.affected_users)
        
        # –ë–ª–æ–∫–∏—Ä—É–µ–º –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–µ IP –∞–¥—Ä–µ—Å–∞
        if incident.severity in [IncidentSeverity.HIGH, IncidentSeverity.CRITICAL]:
            await self._block_suspicious_ips(incident)
    
    async def _handle_unauthorized_access(self, incident: SecurityIncident):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ—Å–∞–Ω–∫—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞"""
        
        # –í—Ä–µ–º–µ–Ω–Ω–æ –±–ª–æ–∫–∏—Ä—É–µ–º –∑–∞—Ç—Ä–æ–Ω—É—Ç—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã
        for user_id in incident.affected_users:
            await self._temporarily_suspend_user(user_id, reason="security_incident")
        
        # –ê—É–¥–∏—Ç –¥–µ–π—Å—Ç–≤–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await self._audit_user_actions(incident.affected_users)
        
        # –£—Å–∏–ª–∏–≤–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
        await self._increase_monitoring_level(incident.affected_systems)
    
    async def _immediate_containment(self, incident: SecurityIncident):
        """–ù–µ–º–µ–¥–ª–µ–Ω–Ω—ã–µ –∑–∞—â–∏—Ç–Ω—ã–µ –º–µ—Ä—ã"""
        
        if incident.severity == IncidentSeverity.CRITICAL:
            # –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –∏–Ω—Ü–∏–¥–µ–Ω—Ç - –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –∑–∞—â–∏—Ç–Ω—ã–π —Ä–µ–∂–∏–º
            await self._activate_protection_mode()
        
        # –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ü–∏–¥–µ–Ω—Ç
        logger.critical(f"SECURITY INCIDENT: {incident.incident_id} - {incident.description}")
    
    async def _notify_security_team(self, incident: SecurityIncident):
        """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏"""
        
        notification = f"""
üö® SECURITY INCIDENT ALERT üö®

Incident ID: {incident.incident_id}
Type: {incident.incident_type.value}
Severity: {incident.severity.value}
Description: {incident.description}
Affected Users: {len(incident.affected_users)}
Detected At: {incident.detected_at}

Immediate action required!
        """
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Slack/Telegram
        await send_security_team_notification(notification)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º email –∞–ª–µ—Ä—Ç
        await send_email_alert(notification)
```

### 14. Compliance & Privacy

**GDPR Compliance Features**:
```python
class PrivacyManager:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def export_user_data(self, user_id: str) -> dict:
        """–≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (GDPR Article 20)"""
        
        user_data = {
            "personal_info": await self._get_user_personal_info(user_id),
            "authentication_logs": await self._get_auth_logs(user_id),
            "game_history": await self._get_game_history(user_id),
            "session_history": await self._get_session_history(user_id),
            "friend_connections": await self._get_friend_data(user_id),
            "custom_templates": await self._get_user_templates(user_id),
            "statistics": await self._get_user_statistics(user_id)
        }
        
        return user_data
    
    async def delete_user_data(self, user_id: str, verification_token: str):
        """–£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (GDPR Article 17)"""
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–∫–µ–Ω –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏
        if not await self._verify_deletion_token(user_id, verification_token):
            raise HTTPException(403, "Invalid verification token")
        
        # –ê–Ω–æ–Ω–∏–º–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –≤–º–µ—Å—Ç–æ –ø–æ–ª–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –¥–ª—è —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏
        await self._anonymize_user_data(user_id)
        
        # –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –≤—Å–µ —Ç–æ–∫–µ–Ω—ã
        await token_cache.invalidate_user_tokens(user_id)
        
        # –õ–æ–≥–∏—Ä—É–µ–º —É–¥–∞–ª–µ–Ω–∏–µ
        await self._log_data_deletion(user_id)
    
    async def update_privacy_consent(self, user_id: str, consents: dict):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–≥–ª–∞—Å–∏–π –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–∞–Ω–Ω—ã—Ö"""
        
        privacy_consent = PrivacyConsent(
            user_id=user_id,
            analytics_consent=consents.get("analytics", False),
            marketing_consent=consents.get("marketing", False),
            data_sharing_consent=consents.get("data_sharing", False),
            updated_at=datetime.utcnow()
        )
        
        await self.db.merge(privacy_consent)
        await self.db.commit()
```

## Verification Checkpoint

### Security Design Verification:

‚úÖ **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è**:
- –ì–∏–±—Ä–∏–¥–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º —á–µ—Ä–µ–∑ Redis
- JWT —Å RS256 –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
- Fallback –º–µ—Ö–∞–Ω–∏–∑–º –¥–ª—è –≤—ã—Å–æ–∫–æ–π –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
- –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ —Ä–æ–ª–µ–π –∏ –ø—Ä–∞–≤

‚úÖ **Telegram Integration**:
- –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ–¥–ø–∏—Å–∏ Telegram Mini Apps
- –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ Bot Token
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ (< 1 —á–∞—Å–∞)
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Telegram User ID

‚úÖ **Performance Requirements**:
- < 5ms –≤–∞–ª–∏–¥–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–∞ —á–µ—Ä–µ–∑ Redis –∫—ç—à
- < 50ms fallback –≤–∞–ª–∏–¥–∞—Ü–∏—è —á–µ—Ä–µ–∑ Auth Service
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ 1000+ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –∏–Ω–≤–∞–ª–∏–¥–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–æ–≤

‚úÖ **Security Standards**:
- OWASP Top 10 compliance
- Rate limiting (5 auth attempts/minute)
- Suspicious activity detection
- Security headers (HSTS, CSP, etc.)
- Incident response procedures

‚úÖ **Session Management**:
- –ú–∞–∫—Å–∏–º—É–º 5 –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–µ–∫—à–∏—Ö —Å–µ—Å—Å–∏–π
- Multi-device support —Å tracking
- Graceful session termination

‚úÖ **Privacy & Compliance**:
- GDPR compliance (data export/deletion)
- Privacy consent management
- Minimal data collection –ø—Ä–∏–Ω—Ü–∏–ø—ã
- Audit logging –¥–ª—è –≤—Å–µ—Ö security events

üé®üé®üé® **EXITING CREATIVE PHASE: JWT AUTHENTICATION & SECURITY** üé®üé®üé®